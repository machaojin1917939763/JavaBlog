---
title: 项目自测
order: 2
category:
  - 项目
tag:
  - 项目
---



有关项目可能被问到的问题（8月22日需要弄清楚的）

## 1、项目的难点在哪，你是如何解决的？

## 2、怎么想的，为什么要做这个项目？

## 3、技术是怎么选型的，怎么落地的？

## 4、用到了哪些技术？为什么要用这些技术？

## 5、画出商品的构造图？

## 6、相比于其他的同类项目，你的项目有什么优势？

## 7、介绍一下你的项目

## 8、商品表是怎么设计的？有哪些字段？

## 9、分类表是如何设计的？

## 10、品牌表是怎么设计的？

## 11、什么是SPU和SKU，他们之间的关系是什么？

## 12、什么是基本属性，什么是销售属性？

## 13、怎么实现的新增商品？具体的流程画一下

## 14、新增商品中调用了其他服务，那如果新增商品过程中失败了，怎么回滚？

## 15、说一下seata？什么是XC，什么是XA？有什么缺点？

## 16、什么是柔性事务？

## 17、什么是TCC，两阶段提交是什么？

## 18、商品是如何上架的？

## 19、为什么要用elasticsearch作为商品的上架数据库？

## 20、怎么实现的数据持久化？

## 21、说一下elasticsearch的优点？

## 22、什么是倒排索引？

## 23、说一下添加商品所涉及到的模块？

## 24、什么是OSS？

## 25、openfeign如何使用？

## 26、openfeign是http请求还是RPC请求？

## 27、如果远程调用失败了如何实现快速返回？

## 28、什么是服务降级，服务熔断，服务？？？？

## 29、分类是如何实现的？

## 30、如何实现登录？

## 31、什么是outh2登录？

## 32、什么时候shiro、springsecurity

## 33、什么是单点登录？

## 34、outh2的流程？

## 35、能不能在用户注册的时候使用单点登录？

## 36、订单详情是怎么实现的？

## 37、购物车是怎么实现的，为什么要怎么设计？

## 38、如何实现用户未登录添加购物车？

## 39、怎么实现的商品搜索？

## 40、下单流程?

1. **订单确认** (`confirmOrder` 方法)
   - 获取当前登录用户的信息。
   - 查询所有选中的购物项。
   - 查询库存信息。
   - 查询用户的所有收货地址。
   - 获取用户的积分信息。
   - 获取优惠券
   - 生成一个防重令牌，并将其存储在Redis中，用于后续的订单提交验证。
2. **订单提交** (`submitOrder` 方法)
   - 验证防重令牌：确保订单不会被重复提交。
   - 创建订单和订单项。
   - 验证价格：确保订单的总价与用户提交的价格匹配。
   - 保存订单。
   - 锁定库存：确保商品有足够的库存。
   - 如果库存锁定成功，将订单信息发送到RabbitMQ的订单延迟队列，用于后续的订单超时检查。
   - 清除购物车中已下单的商品。
3. **订单支付** (`getOrderPay` 方法)
   - 根据订单号查询订单信息。
   - 获取订单的支付信息，如订单总价、订单商品名称等。
4. **处理支付结果** (`handlerPayResult` 方法)
   - 保存支付的交易流水信息。
   - 根据支付结果更新订单状态。
5. **关闭过期订单** (`closeOrder` 方法)
   - 查询订单的最新状态。
   - 如果订单仍然是新创建状态并且超时未支付，则关闭订单。
   - 关闭订单后，发送消息到RabbitMQ，通知其他服务进行关单相关的操作，如解锁库存。

此外，还有一些辅助方法，如创建订单、构建订单项、计算价格等。

## 41、如何实现接口幂等性？

接口幂等性是确保一个接口被多次调用时，其效果与被调用一次时的效果相同，不会产生不良影响。实现接口幂等性的方法有很多，以下是一些常见的方法：

1. **使用唯一标识符**：为每个请求分配一个唯一的ID。在处理请求之前，检查该ID是否已经被处理过。如果已经处理过，那么直接返回之前的结果，否则继续处理请求。
2. **乐观锁**：在数据库中使用版本号或时间戳字段。当更新数据时，检查版本号或时间戳是否与数据库中的值匹配。如果匹配，执行更新并增加版本号或更新时间戳。如果不匹配，说明数据已经被其他请求修改过，因此拒绝请求。
3. **分布式锁**：在分布式系统中，可以使用分布式锁来确保同一时间只有一个请求能够执行。例如，可以使用Redis或Zookeeper来实现分布式锁。
4. **Token机制**：为每个请求生成一个Token。客户端在发送请求时携带这个Token。服务器在接收到请求后，检查Token是否有效。如果有效，处理请求并使Token失效。如果Token已经失效，说明请求已经被处理过，直接返回之前的结果。
5. **预检请求**：在处理请求之前，先发送一个预检请求来检查是否可以执行真正的请求。只有在预检请求成功后，才发送真正的请求。
6. **数据库约束**：使用数据库的唯一约束或主键约束来防止重复插入数据。
7. **幂等框架**：使用专门的幂等框架，如Idempotent框架，来自动处理幂等性问题。

以上是一些常见的实现接口幂等性的方法。在实际应用中，可以根据具体的业务场景和需求选择合适的方法。

## 42、什么是防重令牌？有哪些实现？

## 43、RabbitMQ没有延迟队列怎么实现的延迟队列？

## 44、锁定库存，下单失败怎么解锁？

## 45、超时取消订单的视线？

## 46、如果我这次订单提交失败了，但是页面还没交跳转，但是防冲令牌失效了，怎么处理？

**弄清楚shiro、SpringSecurity、单点登录、outh2，完成一道算法题、投递简历**