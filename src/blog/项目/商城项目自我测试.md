---
title: 项目自测
order: 2
category:
  - 项目
tag:
  - 项目
---



有关项目可能被问到的问题（8月22日需要弄清楚的）

## 1、项目的难点在哪，你是如何解决的？

## 2、怎么想的，为什么要做这个项目？

## 3、技术是怎么选型的，怎么落地的？

## 4、用到了哪些技术？为什么要用这些技术？

1. **Java**: 
    - **为什么**：Java 是一个成熟、稳定且广泛使用的编程语言。它的跨平台能力、强大的标准库和丰富的开源生态系统使其成为企业级应用的首选。
    - **在项目中的应用**：Java 作为主要的后端开发语言，处理业务逻辑、数据处理等。

2. **Spring Boot & Spring Cloud (微服务)**:
    - **为什么**：Spring Boot 提供了快速开发、自动配置和生产级别的运行时。Spring Cloud 提供了一套微服务解决方案，包括服务发现、配置中心、负载均衡等。
    - **在项目中的应用**：项目采用微服务架构，每个功能模块作为一个独立的服务运行。Spring Cloud 提供了服务之间的通信、配置管理等功能。

3. **MyBatis**:
    - **为什么**：MyBatis 提供了灵活的 SQL 查询和结果映射，与 JDBC 相比，它大大简化了数据库操作代码。
    - **在项目中的应用**：用于与 MySQL 数据库进行交互，处理数据的查询、插入、更新和删除。

4. **MySQL**:
    - **为什么**：MySQL 是一个开源、高性能、稳定的关系型数据库，适合存储结构化数据。
    - **在项目中的应用**：存储项目的主要数据，如用户信息、订单、商品等。

5. **Redis**:
    - **为什么**：Redis 提供了超高速的数据访问速度，适合作为缓存、会话存储或轻量级的消息队列。
    - **在项目中的应用**：用于缓存频繁访问的数据，如购物车信息、用户会话等。

6. **Docker**:
    - **为什么**：Docker 提供了容器化的解决方案，确保应用在不同环境中的一致性。
    - **在项目中的应用**：用于打包、部署和运行微服务。

7. **Vue.js**:
    - **为什么**：Vue.js 是一个轻量级、易于上手且功能强大的前端框架。
    - **在项目中的应用**：构建项目的前端界面，与后端微服务交互。

8. **Nginx**:
    - **为什么**：Nginx 是一个高性能的 web 服务器，也可以作为反向代理、负载均衡器。
    - **在项目中的应用**：处理客户端的请求，将其转发到相应的微服务。

9. **RabbitMQ (消息队列)**:
    - **为什么**：在微服务架构中，服务之间的直接调用可能会导致耦合度增加。消息队列提供了一种异步通信方式，解耦服务之间的依赖。
    - **在项目中的应用**：处理服务之间的异步通信，如订单创建、库存更新等。

10. **Elasticsearch (搜索引擎)**:
    - **为什么**：提供了快速的文本搜索和数据分析能力。
    - **在项目中的应用**：用于商品搜索、日志分析等。

选择这些技术的原因是基于它们的性能、稳定性、社区支持以及与其他技术的集成能力。微服务架构使得每个服务可以独立开发、部署和扩展，提高了系统的可维护性和可扩展性。

## 5、画出商品的构造图？

## 6、相比于其他的同类项目，你的项目有什么优势？

这个项目是一个致力于打造完整的大型分布式架构电商平台的项目。从项目的描述和技术选型中，我们可以识别出以下优势：

1. **完整的电商功能**：项目不仅包括前台的商城系统（如用户登录、注册、商品搜索、商品详情、购物车、订单、秒杀活动等），还包括后台的管理系统（如系统管理、商品系统、优惠营销、库存系统、订单系统、用户系统、内容管理等）。
2. **现代技术栈**：项目采用了当前流行的技术，如 SpringCloud、SpringCloud Alibaba、MyBatis Plus、Elasticsearch、RabbitMQ、Redis、Docker 等，这些技术都是当前企业级应用中的热门选择。
3. **微服务架构**：项目基于 SpringCloud 和 SpringCloud Alibaba 实现微服务架构，这意味着每个功能模块都作为一个独立的服务运行，这样的架构可以提高系统的可扩展性和可维护性。
4. **前后端分离**：项目采用前后端分离的方式编写，这样可以使前端和后端独立开发和部署，提高开发效率。
5. **代码生成器**：项目中包含了人人开源项目的代码生成器，这可以大大加速开发速度，减少重复代码的编写。
6. **容器化部署**：项目支持 Docker，这意味着可以确保应用在不同环境中的一致性，并简化部署和扩展的过程。
8. **高性能和高可用性**：通过使用 Nginx、Redis、RabbitMQ、Elasticsearch 等技术，项目可以实现高性能、高可用性和高并发。

相比于其他同类项目，谷粒商城的优势在于其完整的功能、现代的技术栈、微服务架构、前后端分离的设计、丰富的学习资源和容器化部署。这些特点使其成为一个非常适合学习和实践的项目。

## 7、介绍一下你的项目

## 8、商品表是怎么设计的？有哪些字段？

## 9、分类表是如何设计的？

## 10、品牌表是怎么设计的？

## 11、什么是SPU和SKU，他们之间的关系是什么？

SPU 和 SKU 是电商领域中常用的术语，它们分别代表了商品的两个不同层次的概念。

1. **SPU (Standard Product Unit) - 标准化产品单位**:
   - SPU 是商品信息聚合的最小单位。它通常表示某一款商品的共同特性。
   - 例如，一个型号的手机，不论其颜色、存储容量等都属于同一个SPU。

2. **SKU (Stock Keeping Unit) - 库存量单位**:
   - SKU 是商品库存的最小单位。对于一个SPU，根据其不同的属性（如颜色、尺寸、规格等），可以有多个SKU。
   - 例如，同一个型号的手机，根据颜色和存储容量的不同，可以有多个SKU，如“黑色、64GB”或“白色、128GB”。

### 他们之间的关系：

- 一个SPU下面可以有多个SKU。换句话说，SKU是SPU的细化。
- SPU关注的是商品的共同特性，而SKU关注的是商品的区别特性。
- 在购买商品时，用户通常会选择一个具体的SKU进行购买，而不是SPU。

以手机为例：
- SPU可能是“iPhone 12”这款手机的所有共同特性。
- SKU则可能是“iPhone 12, 黑色, 64GB”或“iPhone 12, 白色, 128GB”。

总之，SPU和SKU是电商领域中描述商品的两个重要概念，它们帮助商家更好地管理商品信息和库存。

## 12、什么是基本属性，什么是销售属性？

在电商领域，商品属性通常被分为两类：基本属性和销售属性。这两种属性对于商品的描述和销售都起到了关键的作用。

1. **基本属性 (也称为非销售属性)**:
   - 描述商品的固有特性和基本信息。
   - 这些属性通常对于一个商品系列或SPU是固定的，不会因为用户的选择而改变。
   - **示例**：对于一款手机，其基本属性可能包括品牌、屏幕尺寸、处理器型号、摄像头像素等。

2. **销售属性**:
   - 描述商品的可选特性，通常会影响商品的SKU。
   - 用户在购买商品时可以选择的属性，基于这些属性的不同组合，商品可能有不同的价格、库存等。
   - **示例**：对于同一款手机，其销售属性可能包括颜色、存储容量等。不同的颜色和存储容量组合会产生不同的SKU，每个SKU可能有不同的价格和库存。

### 它们之间的关系：
- **基本属性**为用户提供了商品的基本信息和特性，帮助用户了解商品的主要功能和规格。
- **销售属性**则为用户提供了购买选择，基于这些选择，用户可以购买到满足自己需求的具体商品版本或型号。

在电商平台上，基本属性和销售属性都是非常重要的。基本属性帮助用户了解商品的主要特性，而销售属性则影响用户的购买决策和购买体验。

## 13、怎么实现的新增商品？具体的流程画一下

## 14、新增商品中调用了其他服务，那如果新增商品过程中失败了，怎么回滚？

在微服务架构中，由于服务之间是分布式的，传统的数据库事务方法（如 RDBMS 的 ACID 事务）不再适用。当在一个微服务中的操作依赖于其他微服务的操作时，需要使用一种称为“分布式事务”的方法来确保数据的一致性。

为了处理分布式事务和确保在失败时能够回滚操作，通常采用以下策略：

1. **Saga模式**:
   - Saga 是一种长寿命的事务，它由多个子事务组成，每个子事务都是一个独立的事务。
   - 如果某个子事务失败，Saga 会执行相应的补偿事务来回滚之前的操作。
   - Saga 可以是串行的或并行的，并且可以通过事件、消息队列或其他机制来协调。

2. **两阶段提交 (2PC)**:
   - 这是一种经典的分布式事务协议，但由于其性能开销和其他问题，它在微服务架构中不太受欢迎。

3. **TCC (Try-Confirm-Cancel)**:
   - TCC 是一种补偿型事务模式，它包括三个步骤：尝试、确认和取消。
   - 在尝试阶段，系统预留必要的资源；在确认阶段，系统真正执行事务；如果事务失败，系统在取消阶段释放预留的资源。

4. **消息驱动的事务**:
   - 使用消息队列（如 RabbitMQ、Kafka）来确保数据的一致性。
   - 如果一个服务的操作失败，它可以发送一个消息到消息队列，通知其他服务回滚其操作。

5. **幂等性**:
   - 确保服务的操作是幂等的，这意味着无论操作执行多少次，结果都是相同的。
   - 这可以确保在失败和重试的情况下，数据仍然保持一致。

在实际应用中，选择哪种策略取决于具体的业务需求、系统的复杂性和其他因素。但无论选择哪种策略，都需要确保在分布式环境中数据的一致性和完整性。

## 15、说一下seata？什么是XC，什么是XA？有什么缺点？

**Seata**（之前称为Fescar）是一个开源的分布式事务解决方案，旨在提供高性能和简单易用的分布式事务服务。Seata 的主要目标是简化分布式事务的复杂性，使其与本地事务一样简单。

### Seata 的核心概念：

1. **全局事务**：由一系列分支事务组成的事务。
2. **分支事务**：一个全局事务中的局部事务段。
3. **TC (Transaction Coordinator)**：全局事务协调者，负责全局事务的开始、提交和回滚。
4. **TM (Transaction Manager)**：控制全局事务的边界，即开始或提交一个全局事务。
5. **RM (Resource Manager)**：控制分支事务，负责分支事务的资源（如数据库连接）的管理。

### XA 和 XC：

1. **XA**：是一个由 X/Open 组织定义的两阶段提交协议。它是一个全球标准，用于在分布式系统中协调事务。
   - 第一阶段：所有参与者都被询问是否可以提交事务。
   - 第二阶段：基于第一阶段的结果，协调者决定提交或回滚事务，并通知所有参与者。

2. **XC**：是 Seata 的自定义协议，它是基于 XA 的改进版本，但更加轻量级和高效。

### Seata 的缺点：

1. **性能开销**：虽然 Seata 旨在提供高性能的分布式事务解决方案，但与传统的单体应用事务相比，它仍然带来了额外的性能开销。
2. **复杂性**：引入分布式事务会增加系统的复杂性，需要更多的配置和管理。
3. **资源锁定**：在某些情况下，Seata 可能需要锁定资源，直到全局事务提交或回滚，这可能会影响系统的吞吐量。
4. **依赖外部存储**：Seata 需要一个外部的存储系统（如数据库）来存储事务日志，这增加了系统的复杂性和故障点。

尽管 Seata 有这些缺点，但它仍然是一个非常有用的工具，特别是对于需要确保数据一致性的分布式应用。

### 1. TC (Transaction Coordinator) - 事务协调者：

- **职责**：TC 是 Seata 的核心组件，负责协调全局事务的提交或回滚。

- 工作流程

  ：

  - 当 TM 请求开始一个新的全局事务时，TC 会生成一个全局事务ID。
  - 当各个参与的微服务（通过 RM）报告其本地事务的状态时，TC 跟踪这些状态。
  - 在全局事务提交时，TC 决定是否所有参与的微服务都可以提交其本地事务，或者是否需要回滚。

- **存储**：TC 通常需要一个持久化存储（如数据库）来记录事务日志，以确保在系统故障时可以恢复事务状态。

### 2. TM (Transaction Manager) - 事务管理器：

- **职责**：TM 负责定义全局事务的边界，即开始和结束一个全局事务。

- 工作流程

  ：

  - TM 通过调用 TC 来开始一个新的全局事务，并获得一个全局事务ID。
  - 在全局事务中，TM 可以调用多个微服务来执行业务操作。
  - 一旦所有业务操作都完成，TM 决定提交或回滚全局事务，并通知 TC。

### 3. RM (Resource Manager) - 资源管理器：

- **职责**：RM 负责管理资源，如数据库连接，以及执行本地事务。

- 工作流程

  ：

  - 当一个微服务参与到全局事务中时，它的本地事务由 RM 管理。
  - RM 保证本地事务的成功执行，并向 TC 报告其状态。
  - 如果 TC 决定回滚全局事务，RM 负责回滚其本地事务。

- **资源锁定**：为了确保数据的一致性，RM 可能需要锁定资源，直到全局事务提交或回滚。

Seata 和 Saga 模式以及消息型事务都是解决分布式事务问题的策略，但它们的工作方式和应用场景有所不同。以下是它们之间的主要区别：

### 1. Seata：

- **工作方式**：Seata 采用了两阶段提交的思想，但进行了优化以适应微服务环境。它包括三个主要组件：TM (Transaction Manager)、RM (Resource Manager) 和 TC (Transaction Coordinator)。
- **特点**：
  - 提供了 AT、TCC、XA 和 SAGA 四种模式。
  - AT 模式是 Seata 的默认模式，它通过拦截 SQL 语句并记录前后镜像来实现自动回滚。
  - TCC 模式需要用户定义 Try、Confirm 和 Cancel 三个操作。
  - XA 模式是传统的两阶段提交。
  - SAGA 模式是基于状态机的长事务处理。
- **适用场景**：当需要确保多个微服务间的数据一致性时。

### 2. Saga 模式：

- **工作方式**：Saga 是一种长寿命的事务，由多个子事务组成。如果某个子事务失败，Saga 会执行相应的补偿事务来回滚之前的操作。
- **特点**：
  - 不是原子性的，而是确保最终一致性。
  - 可以是串行的或并行的。
  - 需要为每个操作定义补偿操作。
- **适用场景**：当原子性不是首要关注点，但需要确保最终一致性时。

### 3. 消息型事务：

- **工作方式**：使用消息队列来确保分布式事务的一致性。如果一个服务的操作失败，它可以发送一个消息到消息队列，通知其他服务回滚其操作。
- **特点**：
  - 基于事件驱动的架构。
  - 需要确保消息的可靠性和消费的幂等性。
  - 可能需要额外的机制来处理消息的重试和死信。
- **适用场景**：当系统已经采用了事件驱动的架构，或者当需要确保跨多个服务的操作的一致性时。

### 总结：

- **Seata** 提供了一个全面的分布式事务解决方案，支持多种模式，适合大多数场景。
- **Saga 模式** 更加灵活，但需要为每个操作定义补偿操作，适合确保最终一致性的场景。
- **消息型事务** 适合事件驱动的架构，需要确保消息的可靠性和消费的幂等性。

选择哪种策略取决于具体的业务需求、系统的复杂性和其他因素。

## 16、什么是柔性事务？

## 17、什么是TCC，两阶段提交是什么？

## 18、商品是如何上架的？

## 19、为什么要用elasticsearch作为商品的上架数据库？

## 20、怎么实现的数据持久化？

## 21、说一下elasticsearch的优点？

## 22、什么是倒排索引？

## 23、说一下添加商品所涉及到的模块？

## 24、什么是OSS？

## 25、openfeign如何使用？

## 26、openfeign是http请求还是RPC请求？

## 27、如果远程调用失败了如何实现快速返回？

## 28、什么是服务降级，服务熔断，服务？？？？

## 29、分类是如何实现的？

## 30、如何实现登录？

## 31、什么是outh2登录？

## 32、什么时候shiro、springsecurity

## 33、什么是单点登录？

## 34、outh2的流程？

## 35、能不能在用户注册的时候使用单点登录？

## 36、订单详情是怎么实现的？

## 37、购物车是怎么实现的，为什么要怎么设计？

购物车的数据结构主要由两个类组成：`CartVo` 和 `CartItemVo`。

1. **CartItemVo（购物车项）**:
   - `skuId`: 商品的SKU ID。
   - `check`: 商品是否被选中。
   - `title`: 商品的标题。
   - `image`: 商品的图片。
   - `skuAttrValues`: 商品的套餐属性。
   - `price`: 商品的单价。
   - `count`: 商品的数量。
   - `totalPrice`: 商品的总价，计算方式为单价乘以数量。
2. **CartVo（购物车）**:
   - `items`: 购物车中的所有商品项，是一个 `CartItemVo` 的列表。
   - `countNum`: 购物车中的商品总数量。
   - `countType`: 购物车中的商品种类数量。
   - `totalAmount`: 购物车中的商品总价。
   - `reduce`: 减免的价格。

这两个类的设计反映了购物车的基本结构：购物车由多个购物车项组成，每个购物车项代表一个商品及其相关信息。购物车还包括商品的总数量、种类数量、总价和减免价格等信息。

## 38、如何实现用户未登录添加购物车？

## 39、怎么实现的商品搜索？

## 40、下单流程?

1. **订单确认** (`confirmOrder` 方法)
   - 获取当前登录用户的信息。
   - 查询所有选中的购物项。
   - 查询库存信息。
   - 查询用户的所有收货地址。
   - 获取用户的积分信息。
   - 获取优惠券
   - 生成一个防重令牌，并将其存储在Redis中，用于后续的订单提交验证。
2. **订单提交** (`submitOrder` 方法)
   - 验证防重令牌：确保订单不会被重复提交。
   - 创建订单和订单项。
   - 验证价格：确保订单的总价与用户提交的价格匹配。
   - 保存订单。
   - 锁定库存：确保商品有足够的库存。
   - 如果库存锁定成功，将订单信息发送到RabbitMQ的订单延迟队列，用于后续的订单超时检查。
   - 清除购物车中已下单的商品。
3. **订单支付** (`getOrderPay` 方法)
   - 根据订单号查询订单信息。
   - 获取订单的支付信息，如订单总价、订单商品名称等。
4. **处理支付结果** (`handlerPayResult` 方法)
   - 保存支付的交易流水信息。
   - 根据支付结果更新订单状态。
5. **关闭过期订单** (`closeOrder` 方法)
   - 查询订单的最新状态。
   - 如果订单仍然是新创建状态并且超时未支付，则关闭订单。
   - 关闭订单后，发送消息到RabbitMQ，通知其他服务进行关单相关的操作，如解锁库存。

此外，还有一些辅助方法，如创建订单、构建订单项、计算价格等。

## 41、如何实现接口幂等性？

接口幂等性是确保一个接口被多次调用时，其效果与被调用一次时的效果相同，不会产生不良影响。实现接口幂等性的方法有很多，以下是一些常见的方法：

1. **使用唯一标识符**：为每个请求分配一个唯一的ID。在处理请求之前，检查该ID是否已经被处理过。如果已经处理过，那么直接返回之前的结果，否则继续处理请求。
2. **乐观锁**：在数据库中使用版本号或时间戳字段。当更新数据时，检查版本号或时间戳是否与数据库中的值匹配。如果匹配，执行更新并增加版本号或更新时间戳。如果不匹配，说明数据已经被其他请求修改过，因此拒绝请求。
3. **分布式锁**：在分布式系统中，可以使用分布式锁来确保同一时间只有一个请求能够执行。例如，可以使用Redis或Zookeeper来实现分布式锁。
4. **Token机制**：为每个请求生成一个Token。客户端在发送请求时携带这个Token。服务器在接收到请求后，检查Token是否有效。如果有效，处理请求并使Token失效。如果Token已经失效，说明请求已经被处理过，直接返回之前的结果。
5. **预检请求**：在处理请求之前，先发送一个预检请求来检查是否可以执行真正的请求。只有在预检请求成功后，才发送真正的请求。
6. **数据库约束**：使用数据库的唯一约束或主键约束来防止重复插入数据。
7. **幂等框架**：使用专门的幂等框架，如Idempotent框架，来自动处理幂等性问题。

以上是一些常见的实现接口幂等性的方法。在实际应用中，可以根据具体的业务场景和需求选择合适的方法。

## 42、什么是防重令牌？有哪些实现？

## 43、RabbitMQ没有延迟队列怎么实现的延迟队列？

## 44、锁定库存，下单失败怎么解锁？

## 45、超时取消订单的视线？

## 46、如果我这次订单提交失败了，但是页面还没交跳转，但是防冲令牌失效了，怎么处理？

## 47、临时购物车和用户登录时的购物车是怎么实现的？

购物车的实现考虑了用户的登录状态，具体实现如下：

1. **购物车拦截器（CartInterceptor）**:
   - 在每次请求前，拦截器会检查用户是否已登录。
   - 如果用户已登录，会从会话中获取用户的信息，并设置到 `UserInfoTo` 对象中。
   - 如果用户未登录，会检查请求中是否有一个名为 `user-key` 的cookie。这个 `user-key` 是用来标识临时用户的。
   - 如果没有 `user-key`，会为用户生成一个，并设置到 `UserInfoTo` 对象中。
   - 在请求处理完后，如果用户是临时用户，会将 `user-key` 设置到cookie中。
2. **购物车服务实现（CartServiceImpl）**:
   - 服务中有一个 `getCart` 方法，用于获取购物车的内容。
   - 如果用户未登录，直接使用 `user-key` 从Redis中获取临时购物车的内容。
   - 如果用户已登录，会先获取用户的购物车内容，然后检查是否有临时购物车。如果有，会将临时购物车的内容合并到用户的购物车中，并更新到Redis。
   - 合并完成后，会删除临时购物车的数据。
3. **用户信息传递对象（UserInfoTo）**:
   - 这是一个简单的数据对象，用于在拦截器和服务之间传递用户信息。
   - 包含用户ID、`user-key` 和一个标志，表示用户是否是临时用户。

总的来说，当用户未登录时，系统会为其创建一个临时的购物车，并使用一个特定的 `user-key` 来标识。当用户登录后，系统会检查是否有临时购物车，如果有，会将其内容合并到用户的购物车中，并删除临时购物车。这种设计允许未登录的用户也可以使用购物车功能，而在登录后，他们之前添加到购物车的商品不会丢失。

## 48、临时购物车在redis中的数据结构是什么？是使用什么进行存储的？


临时购物车和登录用户的购物车都是存储在Redis中的。具体的数据结构和存储方式如下：

1. **数据结构**:
   - 购物车数据在Redis中是以哈希结构存储的。每个购物车（无论是临时的还是登录用户的）都有一个唯一的key，这个key是由前缀（例如："CART_PREFIX"）和用户ID或`user-key`组成的。
   - 每个购物车项（CartItemVo）都是以其`skuId`作为哈希的字段名，而购物车项的数据（经过JSON序列化后的字符串）作为哈希的字段值。
2. **存储方式**:
   - 使用Spring的`StringRedisTemplate`和`BoundHashOperations`进行操作。
   - `BoundHashOperations`是Spring Data Redis提供的一个接口，它提供了一系列方法来操作Redis的哈希结构。
   - 在`CartServiceImpl`中，有一个`getCartItemOps`的私有方法，这个方法会根据用户的登录状态返回一个`BoundHashOperations`对象，这个对象绑定了购物车的key，可以用来操作该购物车在Redis中的数据。

具体来说，当需要添加一个商品到购物车时，会首先检查这个商品（通过`skuId`）是否已经在购物车中。如果已经存在，就更新其数量；如果不存在，就添加一个新的字段到哈希中。其他的操作，如删除商品、更改数量等，也都是基于这个哈希结构进行的。

让我们详细看一下代码：

1. **购物车在Redis中的存储方式**:

```java
private BoundHashOperations<String, Object, Object> getCartItemOps() {
    //1判断是否已经登录
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    //1.1 登录使用userId操作redis
    if (!StringUtils.isEmpty(userInfoTo.getUserId())) {
        return redisTemplate.boundHashOps(CartConstant.CART_PREFIX + userInfoTo.getUserId());
    } else {
        //1.2 未登录使用user-key操作redis
        return redisTemplate.boundHashOps(CartConstant.CART_PREFIX + userInfoTo.getUserKey());
    }
}
```

解释:
- 这个`getCartItemOps`方法用于获取一个`BoundHashOperations`对象，这个对象绑定了购物车的key，可以用来操作该购物车在Redis中的数据。
- 首先，从`CartInterceptor`的`threadLocal`中获取当前用户的信息。
- 如果用户已登录（即`userId`不为空），则使用`userId`作为key的一部分；否则，使用`user-key`作为key的一部分。
- 最后，使用`redisTemplate.boundHashOps`方法获取一个绑定了购物车key的`BoundHashOperations`对象。

2. **添加商品到购物车**:

```java
@Override
public CartItemVo addCartItem(Long skuId, Integer num) {
    BoundHashOperations<String, Object, Object> ops = getCartItemOps();
    // 判断当前商品是否已经存在购物车
    String cartJson = (String) ops.get(skuId.toString());
    // 1 已经存在购物车，将数据取出并添加商品数量
    if (!StringUtils.isEmpty(cartJson)) {
        CartItemVo cartItemVo = JSON.parseObject(cartJson, CartItemVo.class);
        cartItemVo.setCount(cartItemVo.getCount() + num);
        String jsonString = JSON.toJSONString(cartItemVo);
        ops.put(skuId.toString(), jsonString);
        return cartItemVo;
    } else {
        // ... [代码省略，用于处理商品不存在购物车的情况]
    }
}
```

解释:
- 首先，使用`getCartItemOps`方法获取一个`BoundHashOperations`对象。
- 使用`ops.get`方法尝试从Redis中获取该商品的数据。
- 如果商品已经存在购物车中（即`cartJson`不为空），则解析这个JSON字符串，获取一个`CartItemVo`对象，然后增加商品的数量，并将更新后的数据存回Redis。
- 如果商品不存在购物车中，后面的代码（这里省略了）会处理这种情况，例如添加新的商品到购物车。

通过这种方式，购物车的数据结构在Redis中是一个哈希，其中每个字段名是商品的`skuId`，字段值是商品数据的JSON字符串。这种结构使得对购物车的操作（如添加、删除商品）都非常高效。

## 49、购物车都是存储在redis中的吗？

购物车的数据确实是存储在Redis中的。以下是`CartServiceImpl`中与Redis相关的部分代码及其解释：

1. **获取购物车操作对象**:
```java
private BoundHashOperations<String, Object, Object> getCartItemOps() {
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    if (!StringUtils.isEmpty(userInfoTo.getUserId())) {
        return redisTemplate.boundHashOps(CartConstant.CART_PREFIX + userInfoTo.getUserId());
    } else {
        return redisTemplate.boundHashOps(CartConstant.CART_PREFIX + userInfoTo.getUserKey());
    }
}
```
这个方法根据用户的登录状态返回一个绑定了购物车key的`BoundHashOperations`对象，用于操作Redis中的购物车数据。

2. **获取购物车内容**:
```java
private List<CartItemVo> getCartByKey(String userKey) {
    BoundHashOperations<String, Object, Object> ops = redisTemplate.boundHashOps(CartConstant.CART_PREFIX+userKey);
    List<Object> values = ops.values();
    if (values != null && values.size() > 0) {
        List<CartItemVo> cartItemVos = values.stream().map(obj -> {
            String json = (String) obj;
            return JSON.parseObject(json, CartItemVo.class);
        }).collect(Collectors.toList());
        return cartItemVos;
    }
    return null;
}
```
这个方法根据提供的key（可以是用户ID或`user-key`）从Redis中获取购物车的内容，并将其转换为`CartItemVo`对象的列表。

3. **合并购物车**:
```java
@Override
public CartVo getCart() {
    CartVo cartVo = new CartVo();
    UserInfoTo userInfoTo = CartInterceptor.threadLocal.get();
    List<CartItemVo> tempCart = getCartByKey(userInfoTo.getUserKey());
    if (StringUtils.isEmpty(userInfoTo.getUserId())) {
        cartVo.setItems(tempCart);
    } else {
        List<CartItemVo> userCart = getCartByKey(userInfoTo.getUserId().toString());
        if (tempCart != null && tempCart.size() > 0) {
            for (CartItemVo cartItemVo : tempCart) {
                userCart.add(cartItemVo);
                addCartItem(cartItemVo.getSkuId(), cartItemVo.getCount());
            }
        }
        cartVo.setItems(userCart);
        redisTemplate.delete(CartConstant.CART_PREFIX + userInfoTo.getUserKey());
    }
    return cartVo;
}
```
这个方法首先检查用户是否已登录。如果用户未登录，直接返回临时购物车的内容。如果用户已登录，会合并临时购物车和用户的购物车，并将合并后的购物车存储在Redis中。

从上述代码中，我们可以看到购物车的数据确实是存储在Redis中的，使用哈希结构来存储每个购物车项。这种设计可以确保购物车的操作速度快，同时也方便合并临时购物车和用户的购物车。

## 50、购物车中存储的了用户的购物车，当商品的数量很多时，redis可能会被挤满，如果redis宕机，那么用户的购物车数据就会消失，这样风险很大

您提到的问题确实是在使用Redis作为购物车存储时需要考虑的。Redis虽然提供了快速的读写性能，但它是一个内存数据库，所以存储空间是有限的。此外，由于它主要存储在内存中，如果没有适当的持久化策略或备份策略，数据可能会在Redis宕机或重启时丢失。

为了解决这些问题，可以考虑以下策略：

1. **持久化**:
   - Redis提供了几种持久化机制，如RDB快照和AOF日志。可以根据业务需求选择合适的持久化策略，以确保数据的安全。
   - RDB会在指定的时间间隔内生成数据集的时间点快照。
   - AOF会记录服务器接收到的每个写操作，重启时会重新执行这些命令来恢复数据。

2. **备份**:
   - 定期备份Redis数据，确保在数据丢失时可以从备份中恢复。
   - 可以考虑使用云服务提供商提供的备份和恢复服务。

3. **分片**:
   - 如果数据量非常大，可以考虑使用Redis的分片功能，将数据分布到多个Redis实例上。
   - 这样可以有效地扩展存储容量和处理能力。

4. **混合存储策略**:
   - 考虑将购物车数据存储在关系数据库或其他持久化存储中，而不是完全依赖Redis。
   - Redis可以用作缓存层，提供快速的读写访问，而持久化存储可以确保数据的安全和持久性。

5. **监控和警告**:
   - 使用监控工具监控Redis的内存使用情况，当接近上限时发送警告。
   - 这样可以提前采取措施，避免因内存不足而导致的问题。

6. **数据清理策略**:
   - 定期清理旧的或不再需要的购物车数据，释放存储空间。
   - 可以设置TTL（生存时间）来自动删除过期的数据。

虽然使用Redis存储购物车数据有其优势，但也需要考虑其潜在的风险，并采取适当的策略来确保数据的安全和可靠性。

**弄清楚shiro、SpringSecurity、单点登录、outh2，完成一道算法题、投递简历**