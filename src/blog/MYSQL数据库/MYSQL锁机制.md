---
title: MYSQL锁机制
order: 2
category:
  - MYSQL
tag:
  - MYSQL
---



## 说一下 MySQL 的事务（ACID 特性）

### MySQL 的事务（ACID 特性）

MySQL 的事务是一系列的操作，要么全部执行，要么全部不执行，确保数据的完整性和一致性。事务的核心是 ACID 特性，以下是详细解释：

1. **原子性 (Atomicity)**
    - 原子性确保事务作为一个单独的单位被执行。也就是说，要么全部操作执行，要么全部操作都不执行。
    - 如果事务中的某个操作失败，整个事务都会失败，并将其所做的所有更改回滚到之前的状态。

    ```markdown
    `原子性`是确保事务完整性的关键。
    ```

2. **一致性 (Consistency)**
    
    - 一致性确保事务将数据库从一个状态转移到另一个状态。在事务开始之前和事务结束之后，数据库的完整性约束必须保持不变。
    - 例如，如果一个操作试图将一个负值插入到一个不允许负值的列中，整个事务都会被回滚。
    
    ```markdown
    `一致性`确保数据库的状态始终保持一致。
    ```
    
3. **隔离性 (Isolation)**
    - 隔离性确保并发执行的事务不会互相影响。每个事务都在一个独立的“沙盒”中操作，这意味着所有的操作都是在一个临时的世界中执行的，除非事务被提交。
    - 这可以防止数据损坏，因为每个事务都不会看到其他事务的中间状态。

    ```markdown
    `隔离性`确保每个事务都在其自己的私有环境中运行。
    ```

4. **持久性 (Durability)**
    - 持久性确保一旦事务被提交，其所做的更改就会永久保存在数据库中。即使发生系统崩溃，更改也不会丢失。
    - 这通常是通过将事务日志写入磁盘来实现的。

    ```markdown
    `持久性`确保事务的结果永久地保存在数据库中。
    ```

::: tip 提示
ACID 特性确保数据库事务的可靠性和完整性。
:::

## MySQL 具体有哪些锁、粒度和开销

### MySQL 的锁、粒度和开销

MySQL 提供了多种锁策略，以支持不同的使用场景。以下是 MySQL 中的锁、其粒度和相关开销的概述：

1. **全局锁 (Global Locks)**
   
    - **粒度**: 最粗的锁粒度，涉及整个数据库。
    - **开销**: 非常高，因为它会阻止所有其他操作。
    - **应用**: 例如，当执行`FLUSH TABLES WITH READ LOCK`命令备份数据库时。
    
    ```markdown
    `全局锁`会锁定整个数据库。
    ```
    
2. **表锁 (Table Locks)**
    - **粒度**: 表级别。
    - **开销**: 较高，因为它会锁定整个表，其他线程不能对其进行写操作。
    - **应用**: MyISAM 存储引擎使用表锁。

    ```markdown
    `表锁`会锁定整个表。
    ```

3. **行锁 (Row Locks)**
    - **粒度**: 行级别。
    - **开销**: 相对较低，因为它只锁定特定的行。
    - **应用**: InnoDB 存储引擎使用行锁。

    ```markdown
    `行锁`锁定特定的数据行。
    ```

4. **意向锁 (Intention Locks)**
    - **粒度**: 表级别。
    - **开销**: 中等。
    - **应用**: InnoDB 使用意向锁来表明它想要在更细的粒度上获得锁，例如行锁。

    ```markdown
    `意向锁`是一个预先声明的锁，表示将来可能会锁定某个资源。
    ```

5. **记录锁 (Record Locks)**
    - **粒度**: 单个行记录。
    - **开销**: 与行锁相似。
    - **应用**: InnoDB 对单个行记录进行锁定。

    ```markdown
    `记录锁`锁定单个行记录。
    ```

6. **间隙锁 (Gap Locks)**
    - **粒度**: 两个索引之间的间隙。
    - **开销**: 中等。
    - **应用**: InnoDB 使用间隙锁来防止记录在两个索引之间插入。

    ```markdown
    `间隙锁`锁定索引之间的间隙。
    ```

7. **临键锁 (Next-Key Locks)**
    - **粒度**: 行记录和其前面的间隙。
    - **开销**: 中等。
    - **应用**: InnoDB 使用临键锁，它是记录锁和间隙锁的组合。

    ```markdown
    `临键锁`锁定行记录及其前面的间隙。
    ```

::: tip 提示
不同的锁策略和粒度对性能和并发性有不同的影响。选择正确的锁策略是确保高性能和数据完整性的关键。
:::

## InnoDB 有哪几种行锁？

### InnoDB 的行锁

InnoDB 存储引擎为了实现高并发和数据一致性，提供了几种行锁。以下是 InnoDB 中的行锁类型：

1. **记录锁 (Record Locks)**
    - 锁定一个具体的行记录。
    - 当对一个行记录进行读取或修改操作时，InnoDB 会使用记录锁来锁定该行。

    ```markdown
    `记录锁`锁定特定的行记录。
    ```

2. **间隙锁 (Gap Locks)**
    - 锁定一个索引之间的间隙，但不包括记录本身。
    - 这种锁主要用于防止其他事务在这个间隙中插入新的记录。

    ```markdown
    `间隙锁`锁定索引之间的间隙，但不包括记录本身。
    ```

3. **临键锁 (Next-Key Locks)**
    - 是记录锁和间隙锁的组合。
    - 锁定一个记录以及该记录之前的间隙。
    - 这种锁策略可以确保范围查询的一致性。

    ```markdown
    `临键锁`锁定行记录及其前面的间隙。
    ```

4. **插入意向锁 (Insert Intention Locks)**
    - 是一种特殊类型的间隙锁，用于表明事务打算在某个间隙中插入一个新的记录。
    - 当多个事务都想在同一个间隙中插入记录时，插入意向锁可以确保这些事务按顺序执行。

    ```markdown
    `插入意向锁`表示事务打算在某个间隙中插入新记录。
    ```

::: tip 提示
InnoDB 的行锁策略旨在实现高并发操作，同时确保数据的一致性和完整性。
:::

## InnoDB 行锁的内部实现原理是什么

### InnoDB 行锁的内部实现原理

InnoDB 的行锁实现是基于其索引组织的方式。以下是其内部实现原理的详细描述：

1. **基于索引的锁定**
    - InnoDB 的行锁是基于索引的，无论是主键索引还是辅助索引。如果在没有索引的列上执行锁定操作，InnoDB 会使用隐藏的聚簇索引。
    - 这意味着，为了获得最佳的锁定性能，查询应该使用索引。

    ```markdown
    `基于索引的锁定`意味着所有的行锁操作都与某个索引关联。
    ```

2. **锁定队列**
    - 当一个事务试图锁定一个已经被另一个事务锁定的记录时，它会进入一个锁定队列，等待前一个事务释放锁。
    - InnoDB 使用死锁检测算法来检查和解决可能的死锁情况。

    ```markdown
    `锁定队列`确保事务按照它们请求锁的顺序获得锁。
    ```

3. **多粒度锁定**
    - InnoDB 支持多种锁定粒度，包括行锁、间隙锁和表锁。这允许它在不同的情况下选择最合适的锁定策略。
    - 例如，对于大范围的查询，InnoDB 可能会选择使用表锁而不是行锁。

    ```markdown
    `多粒度锁定`允许 InnoDB 根据操作的性质选择最佳的锁定策略。
    ```

4. **意向锁**
    - InnoDB 使用意向锁来表明一个事务希望获得一个更细粒度的锁。这是一个优化机制，用于减少锁定冲突的可能性。
    - 意向锁是表级别的，它们表明事务打算在表的某个部分上获得行锁。

    ```markdown
    `意向锁`是一个优化机制，用于减少锁定冲突。
    ```

5. **记录、间隙和临键锁**
    - InnoDB 使用记录锁来锁定单个行记录，使用间隙锁来锁定索引之间的间隙，使用临键锁来锁定记录和其前面的间隙。
    - 这些锁策略允许 InnoDB 在保持数据一致性的同时，实现高并发性。

    ```markdown
    `记录、间隙和临键锁`是 InnoDB 的核心锁定策略，用于实现高并发性和数据一致性。
    ```

::: tip 提示
InnoDB 的行锁实现是为了支持高并发操作，同时确保数据的完整性和一致性。
:::

## 锁是如何加载索引上的？

### 锁在索引上的加载方式

InnoDB 的行锁是基于索引的，这意味着锁定机制与索引结构紧密相关。以下是锁如何加载到索引上的详细描述：

1. **B+树索引结构**
    - InnoDB 使用 B+树作为其索引结构，无论是聚簇索引（主键索引）还是非聚簇索引（辅助索引）。
    - 锁定操作主要在这些 B+树的叶子节点上执行，因为叶子节点包含了实际的数据或指向聚簇索引的指针。

    ```markdown
    `B+树索引结构`是 InnoDB 锁定机制的基础。
    ```

2. **记录锁**
    - 当执行一个锁定操作时，InnoDB 会在 B+树索引的相应叶子节点上设置记录锁。
    - 如果查询使用了索引，那么锁会直接应用到索引项上。如果没有使用索引，InnoDB 会回退到聚簇索引（隐藏的主键）。

    ```markdown
    `记录锁`直接锁定 B+树索引的叶子节点。
    ```

3. **间隙锁**
    - 间隙锁不是锁定实际的索引记录，而是锁定两个索引记录之间的间隙。
    - 这种锁确保在锁定期间，没有新的记录可以插入到这个间隙中。

    ```markdown
    `间隙锁`锁定索引记录之间的空隙。
    ```

4. **临键锁**
    - 临键锁是记录锁和间隙锁的组合。
    - 当一个事务锁定一个记录时，它同时锁定该记录和前面的间隙，确保范围查询的一致性。

    ```markdown
    `临键锁`锁定索引记录及其前面的间隙。
    ```

5. **锁的传播**
    - 当使用非聚簇索引（辅助索引）进行查询并需要锁定时，InnoDB 首先在非聚簇索引上设置锁，然后再在聚簇索引上设置锁。
    - 这是因为非聚簇索引的叶子节点包含指向聚簇索引的指针。

    ```markdown
    `锁的传播`从非聚簇索引传递到聚簇索引。
    ```

::: tip 提示
锁在索引上的加载方式是为了确保数据的一致性和完整性，同时支持高并发操作。
:::

## 如果一张表有五个索引，一个加锁语句进来，会不会同时对五个索引加锁？

### 对多索引表的锁定行为

当一张表有多个索引时，一个加锁语句（例如`SELECT ... FOR UPDATE`）进来，它不会对所有的索引都加锁。锁的行为取决于查询使用的索引。以下是详细的解释：

1. **使用的索引**
    - 当执行一个加锁语句时，InnoDB 会根据查询使用的索引来决定锁定哪个索引。
    - 例如，如果你的查询是基于某个特定的索引进行的，那么只有这个索引会被锁定。

    ```markdown
    `使用的索引`决定了锁定哪个索引。
    ```

2. **聚簇索引 (主键索引)**
    - 无论查询使用哪个非聚簇索引（辅助索引），最终的锁定操作都会传播到聚簇索引，因为实际的数据行存储在聚簇索引中。
    - 所以，即使你的查询是基于非聚簇索引的，聚簇索引上的相应行也会被锁定。

    ```markdown
    `聚簇索引`总是涉及锁定，因为它包含实际的数据行。
    ```

3. **锁的粒度**
    - 即使查询使用了某个索引，这并不意味着整个索引都会被锁定。锁的粒度通常是行级的，这意味着只有查询涉及的行会被锁定。

    ```markdown
    `锁的粒度`通常是行级的，不是整个索引。
    ```

::: tip 提示
简而言之，一个加锁语句不会对表中的所有索引都加锁，只会锁定查询实际使用或涉及的索引上的特定行。
:::

