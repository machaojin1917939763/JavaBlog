---
title: MYSQL索引
order: 2
category:
  - MYSQL
tag:
  - MYSQL
---



## MySQL 索引底层结构（B/B+ 树原理与区别）

MySQL 索引底层结构是一个非常有趣的话题，它涉及到数据库的性能和优化。MySQL 支持多种索引类型，其中最常用的是 B-树索引和 B+树索引。这两种索引都是基于平衡多叉树的数据结构，但是有一些区别和特点。我将尝试用简单的语言来解释它们的原理和区别。

B-树索引是一种平衡的多叉树，它的每个节点可以存储多个关键字和指针。关键字按照升序排列，指针指向子节点或者数据记录。B-树索引的每个节点可以存储的关键字个数称为阶数，一般用 m 表示。B-树索引有以下特点：

- 根节点至少有两个子节点，除了根节点外，每个节点至少有 ⌈m/2⌉ 个关键字和 ⌈m/2⌉ 个指针。
- 每个节点至多有 m 个关键字和 m+1 个指针。
- 每个叶子节点都在同一层，并且包含指向数据记录的指针。
- 每个非叶子节点包含 n 个关键字和 n+1 个指针，其中 ⌈m/2⌉ - 1 <= n <= m - 1。
- 每个关键字不仅是索引，还是数据，可以直接访问。

B-树索引的优点是可以快速地在树中查找、插入和删除数据，时间复杂度为 O(logmN)，其中 N 是数据量，m 是阶数。B-树索引的缺点是因为每个节点都存储数据，所以节点的大小有限，不能存储太多的关键字，导致树的高度较高，增加了磁盘 I/O 的次数。另外，B-树索引不适合做范围查询，因为数据分散在各个节点中，没有顺序性。

B+树索引是 B-树索引的变种，也是一种平衡的多叉树，但是有一些不同之处。B+树索引的每个节点仍然可以存储多个关键字和指针，但是只有叶子节点存储指向数据记录的指针，非叶子节点只存储用于索引的关键字。另外，B+树索引的叶子节点之间通过指针相连，形成一个有序链表。B+树索引有以下特点：

- 根节点至少有两个子节点，除了根节点外，每个节点至少有 ⌈m/2⌉ 个关键字和 ⌈m/2⌉ 个指针。
- 每个节点至多有 m 个关键字和 m+1 个指针。
- 每个叶子节点都在同一层，并且包含指向数据记录的指针和指向相邻叶子节点的指针。
- 每个非叶子节点包含 n 个关键字和 n+1 个指针，其中 ⌈m/2⌉ - 1 <= n <= m - 1。
- 每个关键字只是索引，不是数据，只能通过叶子节点访问。

B+树索引的优点是因为只有叶子节点存储数据，所以每个节点可以存储更多的关键字，降低了树的高度和磁盘 I/O 的次数。而且，B+树索引非常适合做范围查询，因为数据有序地存储在叶子节点的链表中，只需要遍历链表即可。B+树索引的缺点是因为每次查询都要到叶子节点，所以单个数据的查询效率没有 B-树索引高。

B-树索引和 B+树索引都是 MySQL 索引底层结构的常见选择，它们各有优缺点，适用于不同的场景。一般来说，B+树索引更适合于大数据量和高并发的环境，因为它可以减少磁盘 I/O 的开销，提高查询效率。

## B树和b+树 的区别？B为什么比B+树高？

B树和B+树是两种常用的多路平衡查找树，它们都可以用于数据库和文件系统的索引。它们的区别主要有以下几点：

- B树的每个节点既存储了关键字，也存储了对应的数据，而B+树的非叶子节点只存储了关键字，用于索引，所有的数据都存储在叶子节点中。
- B树的每个节点的关键字个数等于其子节点的个数减一，而B+树的每个节点的关键字个数等于其子节点的个数。
- B树的每个关键字在整棵树中只出现一次，而B+树的每个关键字在非叶子节点和叶子节点都可能出现，且叶子节点中的关键字是有序的。
- B树的叶子节点没有任何特殊标识，而B+树的叶子节点之间用链表相连，便于范围查找和遍历。

由于这些区别，B树和B+树各有其优势和劣势。一般来说，B+树相比于B树有以下优点：

- B+树由于非叶子节点不存储数据，因此每个节点可以容纳更多的关键字，从而降低了树的高度，减少了磁盘IO次数。
- B+树由于所有数据都在叶子节点中，因此查询性能更稳定，不会出现在非叶子节点就命中的情况。
- B+树由于叶子节点之间用链表相连，因此更适合范围查找和顺序遍历。

当然，B树也有其优点，例如：

- B树由于每个节点都存储了数据，因此当查询命中非叶子节点时，可以直接返回结果，不需要再访问磁盘。
- B树由于每个关键字只出现一次，因此占用的空间更少。



## 你了解的数据库（除了 MySQL）还有哪些结构的索引

除了 MySQL，还有很多其他的数据库系统，它们也使用了不同类型的索引结构来提高查询效率和性能。以下是一些常见的数据库索引结构的例子：

- **Oracle**：Oracle 数据库主要使用 B+树索引，它是 B树索引的一种改进，可以减少树的高度，提高检索速度。Oracle 还支持 Bitmap 索引，它是一种特殊的索引，用于处理低基数（即重复值较多）的列，可以节省空间，提高并发性。
- **SQL Server**：SQL Server 数据库也主要使用 B+树索引，它分为聚集索引和非聚集索引。聚集索引是指数据行的物理顺序与键值的逻辑顺序相同，一个表只能有一个聚集索引。非聚集索引是指数据行的物理顺序与键值的逻辑顺序不同，一个表可以有多个非聚集索引。SQL Server 还支持全文索引，它是一种基于文本内容的索引，可以用于搜索包含特定单词或短语的文档。
- **MongoDB**：MongoDB 是一种非关系型数据库（NoSQL），它主要使用 B树索引，它是一种多路平衡查找树，可以动态地插入和删除数据，保持树的平衡。MongoDB 还支持 Hash 索引，它是一种基于哈希函数的索引，可以快速地进行等值查询。



## MySQL 索引为什么要用 B+ 树？为什么不用红黑树？为什么不用跳表？

简单来说，MySQL 选择 B+ 树作为索引的数据结构，主要是因为 B+ 树具有以下优点：

- B+ 树是一种基于磁盘的平衡多叉树，它可以有效地减少磁盘 I/O 的次数和时间，提高查询效率。B+ 树的高度通常很低（3~4 层），每个节点可以存储多个键值对，每次查询只需要访问少数几个节点即可定位到目标数据。
- B+ 树的非叶子节点只存储键值，不存储数据，这样可以增加每个节点的键值对数量，进一步降低树的高度。而 B 树的非叶子节点既存储键值又存储数据，导致每个节点的键值对数量较少，树的高度较高。
- B+ 树的叶子节点之间通过指针相连，形成一个有序链表，这样可以方便地进行范围查询和排序操作。而 B 树的叶子节点之间没有指针相连，需要通过中序遍历来进行范围查询和排序操作。
- B+ 树的所有键值都在叶子节点上，因此每次查询的时间复杂度都相同，比较稳定。而 B 树的键值分布在各个层次上，因此查询的时间复杂度会随着键值的位置而变化，比较不稳定。

红黑树是一种基于内存的平衡二叉树，它主要用于内部排序和内存对象管理，并不适合作为数据库系统的索引结构。红黑树与平衡二叉树有相同的缺点：

- 红黑树每个节点只存储一个键值对，导致存储空间被浪费。MySQL 在进行磁盘读取时，是以页为单位进行读取，每个页的大小为 16K。如果使用红黑树作为索引结构，那么每次读取一个页只能得到一个键值对，而如果使用 B+ 树作为索引结构，那么每次读取一个页可以得到多个键值对。
- 红黑树由于每个节点只存储一个键值对，导致存储相同数量的数据时，红黑树的深度比 B+ 树的深度更深。这样会增加 MySQL 的磁盘 I/O 次数和时间，降低查询效率。

跳表是一种基于链表的索引结构，它通过在原始链表上增加多级索引来提高查询效率。跳表与 B+ 树相比有以下缺点：

- 跳表需要维护多级索引，这样会增加插入和删除操作的复杂度和开销。而 B+ 树只需要维护一级索引，并且通过分裂和合并操作来保持树的平衡。
- 跳表由于是基于链表实现的，因此无法利用磁盘预读机制来提高磁盘 I/O 的效率。而 B+ 树由于是基于数组实现的，因此可以利用磁盘预读机制来提高磁盘 I/O 的效率。
- 跳表在进行范围查询和排序操作时，需要遍历多个节点，而 B+ 树只需要遍历叶子节点即可。

## B+ 树一般有多少层

B+ 树是一种常用于数据库系统和文件系统的索引结构，它可以有效地减少磁盘 I/O 的次数和时间，提高查询效率。B+ 树的层数取决于它的阶数（每个节点可以存储的键值对数量）和它的数据量（总共有多少个键值对）。一般来说，B+ 树的层数越低，查询效率越高，因为需要访问的节点越少。

在实际的生产环境中，B+ 树的层数通常不会超过 4 层，甚至只有 1-3 层。这是因为在一些常见的数据库系统中，例如 MySQL 的 InnoDB 存储引擎，B+ 树的每个节点（页）的大小默认是 16 KB，而每个键值对占用的空间大约是 14 字节（假设键是 bigint 类型，占用 8 字节，指针是 6 字节）。这样计算出来，每个节点可以存储大约 1170 个键值对。如果假设每个叶子节点存储 16 个键值对（因为叶子节点还要存储数据指针），那么一个高度为 3 的 B+ 树可以存储大约 1170 × 1170 × 16 = 21902400 个键值对，也就是两千多万条记录。这已经是一个很大的数据量了，对于大多数项目也就够用了。如果数据量再大，也应该考虑拆分或分区等方案。

当然，这只是一个粗略的估计，实际上 B+ 树的层数还会受到数据分布、插入删除操作、节点分裂合并等因素的影响。如果想要准确地得到 B+ 树的层数，需要根据具体的数据库系统和表结构进行分析。一种可能的方法是通过查看表空间文件中存储 B+ 树根节点的页，并读取其中记录的 page level 的值，这个值加一就是 B+ 树的高度。



## 索引的优点和缺点（为什么要用索引）

索引是数据库系统中一种用于提高查询效率的数据结构，它可以按照某种排序方式存储表中的一列或多列的值，并指向对应的数据记录。索引的作用类似于书籍的目录，可以帮助用户快速地找到所需的内容。

索引的优点主要有以下几个方面：

- 索引可以大大加快数据的检索速度，减少数据库的 I/O 成本，提高系统性能。这是创建索引的最主要的原因。
- 索引可以通过创建唯一性索引，保证数据库表中每一行数据的唯一性，避免数据冗余和错误。
- 索引可以加速表与表之间的连接，特别是在实现数据的参照完整性方面特别有意义。
- 索引可以在使用分组和排序子句进行数据检索时，显著减少查询中分组和排序的时间，降低 CPU 的消耗。

索引的缺点主要有以下几个方面：

- 索引需要占用额外的物理空间，每一个索引都需要存储一定量的数据，数据量越大，占用空间也越大。
- 索引需要维护额外的时间成本，每次对表中的数据进行增删改操作时，都需要对索引进行动态更新，导致时间变长。
- 索引可能会降低某些查询的效率，例如模糊查询、范围查询等，因为这些查询无法利用索引的有序性，反而增加了索引的搜索开销。

因此，在创建和使用索引时，需要根据具体的业务需求和数据特征进行权衡和优化。一般来说，以下几种情况适合创建索引：

- 表中数据量大且经常进行查询操作的字段。
- 用于排序、分组、联合操作的字段。
- 用于连接其他表的外键字段。
- 值具有唯一性或者分散性较高的字段。

## 建索引的时候有什么需要遵循什么原则？（哪些字段适合建立索引）

建立索引是数据库系统中一种用于提高查询效率的数据结构，它可以按照某种排序方式存储表中的一列或多列的值，并指向对应的数据记录。索引的作用类似于书籍的目录，可以帮助用户快速地找到所需的内容。

建立索引时，需要遵循以下一些原则：

- 选择唯一性索引。唯一性索引的值是唯一的，可以更快速地通过该索引来确定某条记录。例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快地确定某个学生的信息。如果使用姓名的话，可能存在同名现象，从而降低查询速度。
- 为经常需要排序、分组和联合操作的字段建立索引。经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作
- 为常作为查询条件的字段建立索引。如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。
- 限制索引的数目。索引的数目不是越多越好。每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大。修改表时，对索引的重构和更新很麻烦。越多的索引，会使更新表变得很浪费时间。
- 尽量使用数据量少的索引。如果索引的值很长，那么查询的速度会受到影响。例如，对一个 CHAR (100) 类型的字段进行全文检索需要的时间肯定要比对 CHAR (10) 类型的字段需要的时间要多。
- 尽量使用前缀来索引。如果索引字段的值很长，最好使用值的前缀来索引。例如，TEXT 和 BLOG 类型的字段，进行全文检索会很浪费时间。如果只检索字段的前面的若干个字符，这样可以提高检索速度。
- 删除不再使用或者很少使用的索引。表中的数据被大量更新，或者数据的使用方式被改变后，原有的一些索引可能不再需要。数据库管理员应当定期找出这些索引，将它们删除，从而减少索引对更新操作的影响。
- 遵循最左前缀匹配原则。在建立联合索引时，应该将选择性最高（不重复值最多）或者经常作为查询条件（WHERE 子句）或者排序条件（ORDER BY 子句）或者分组条件（GROUP BY 子句）或者联合条件（JOIN 子句）等等情况下出现次数最多且频率最高且重要性最高等等因素综合考虑后选择一个最优字段放在联合索引最左边。
- 选择合适的索引顺序。在联合索引中，可以根据查询需求选择升序或降序进行扫描，以满足精确符合列顺序的 ORDER BY、GROUP BY 和 DISTINCT 等子句的查询需求。

## 一张表最多可以创建多少个索引？

索引是数据库系统中一种用于提高查询效率的数据结构，它可以按照某种排序方式存储表中的一列或多列的值，并指向对应的数据记录。索引的作用类似于书籍的目录，可以帮助用户快速地找到所需的内容。

不同的数据库系统和存储引擎对索引的数量和长度有不同的限制。在 MySQL 中，根据存储引擎定义每个表的最大索引数和最大索引长度。

在 MySQL 5.7 中，最常用的两种存储引擎是 MyISAM 和 InnoDB。它们对索引的限制如下：

- MyISAM：每个表最多支持 64 个索引，每个索引最多支持 16 个列，每个列最大长度为 1000 字节。
- InnoDB：每个表最多支持 64 个二级索引（除了聚簇索引），每个索引最多支持 16 个列，每个列最大长度为 3072 字节。

因此，在 MySQL 中，一张表最多可以创建的索引数目取决于使用的存储引擎和表结构。一般来说，MyISAM 和 InnoDB 的表都可以创建最多 64 个索引，但不建议创建过多的索引，因为这会增加存储空间和维护成本，并可能降低写入性能。

## MySQL 都有哪些类型的索引

MySQL是一种流行的关系型数据库管理系统，它支持多种类型的索引，用于提高查询效率和性能。根据我从网络上搜索到的信息，MySQL目前主要有以下几种索引类型：

- **普通索引**：这是最基本的索引，它没有任何限制，可以加速查询，但不保证列值的唯一性或非空性。
- **唯一索引**：这种索引要求索引列的值必须唯一，但允许有空值。它可以加速查询，同时防止数据重复。
- **主键索引**：这种索引要求索引列的值必须唯一且非空。它可以加速查询，同时保证数据的完整性。一个表只能有一个主键索引。
- **组合索引**：这种索引包含多个列，用于组合搜索。它的效率大于单列索引的合并。创建组合索引时，需要注意列的顺序和选择性。
- **全文索引**：这种索引专门用于文本内容的搜索，它可以对文本进行分词，并支持模糊匹配。目前只有MyISAM和InnoDB存储引擎支持全文索引。

## 唯一索引和普通索引有什么区别，该如何选择？

唯一索引和普通索引是MySQL中两种常见的索引类型，它们的区别和选择主要取决于以下几个方面：

- **唯一性约束**：唯一索引要求索引列的值必须唯一，但可以有空值，而普通索引没有这个限制。如果索引列的值本身就具有唯一性，那么可以使用唯一索引来保证数据的完整性和一致性。如果索引列的值可能有重复，那么只能使用普通索引。
- **查询效率**：唯一索引和普通索引在查询能力上没有明显的差别，都可以通过B+树的搜索算法来加速查询。唯一索引在找到满足条件的记录后会停止继续检索，而普通索引会继续查找下一个记录，直到碰到不满足条件的记录。但是这个差别对于性能的影响可以忽略不计，因为存储引擎是按页读写的，当找到满足条件的记录时，它所在的数据页已经在内存中了，所以多做一次指针寻找和计算的开销很小。
- **更新性能**：唯一索引和普通索引对更新语句的性能影响是比较明显的，主要体现在是否可以使用change buffer这个机制。change buffer是InnoDB存储引擎用来缓存更新操作的一种数据结构，它可以减少随机磁盘访问，提高更新效率。但是change buffer只适用于普通索引，而不适用于唯一索引。因为对于唯一索引来说，所有的更新操作都要先判断是否违反唯一性约束，而这必须要将数据页读入内存才能判断。如果都已经读入内存了，那么直接更新内存会更快，就没必要使用change buffer了。因此，在选择索引类型时，要尽量选择普通索引来利用change buffer的优势。

唯一索引和普通索引的区别和选择主要取决于数据本身的特点和业务需求。如果数据具有唯一性，并且需要保证数据完整性和一致性，那么可以使用唯一索引。如果数据没有唯一性，并且需要提高更新性能，那么可以使用普通索引。如果数据既有唯一性又需要提高更新性能，那么可以考虑使用主键或者组合索引来达到平衡。