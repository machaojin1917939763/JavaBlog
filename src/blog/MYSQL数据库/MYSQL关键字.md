---
title: MYSQL关键字
order: 2
category:
  - MYSQL
tag:
  - MYSQL
---



## where 和 having 的区别

where和having是两种常用的SQL语句，用于对数据进行筛选和过滤。它们的区别主要有以下几点：

- where子句在分组和聚合之前对数据行进行筛选，而having子句在分组和聚合之后对数据行进行筛选。
- where子句中不能使用聚合函数，如sum, count, max等，而having子句中可以使用聚合函数。
- where子句适用于所有类型的查询，包括单表查询，多表连接查询，内连接查询，外连接查询等，而having子句一般只用于分组查询，即带有group by子句的查询。
- where子句和having子句可以组合使用，但是一般建议将连接条件放在where子句中，将分组条件放在having子句中，这样可以提高查询效率和可读性。

下面是一个简单的例子，假设有一个员工表employee，有三个字段emp_id, dept_id, salary，表示员工编号，部门编号和薪水。我们想要查询每个部门的平均薪水，并且只显示平均薪水大于10000的部门。我们可以使用以下SQL语句：

```sql
-- 使用where和having组合
select dept_id, avg(salary) as avg_salary
from employee
where salary > 5000 -- 过滤掉薪水小于5000的员工
group by dept_id -- 按照部门编号分组
having avg(salary) > 10000 -- 过滤掉平均薪水小于10000的部门
```

## innerjoin、leftjoin、rightjoin、union 的区别

inner join, left join, right join和union都是SQL语句中常用的连接操作，用于将两个或多个表的数据进行合并和查询。它们的区别主要有以下几点：

- inner join是指只返回两个表中满足连接条件的记录，也就是两个表的交集部分。例如，如果我们有两个表A和B，分别有以下数据：

| id   | name |
| :--- | :--- |
| 1    | a    |
| 2    | b    |
| 3    | c    |

| id   | age  |
| :--- | :--- |
| 1    | 10   |
| 2    | 20   |
| 4    | 30   |

那么我们可以使用以下SQL语句来进行inner join：

```sql
select A.id, A.name, B.age
from A
inner join B
on A.id = B.id;
```

得到的结果是：

| id   | name | age  |
| :--- | :--- | :--- |
| 1    | a    | 10   |
| 2    | b    | 20   |

可以看到，只有id为1和2的记录在两个表中都存在，所以只返回这两条记录。

- left join是指返回左表中的所有记录，以及右表中满足连接条件的记录，如果右表中没有匹配的记录，则用NULL填充。也就是说，左表是主表，右表是从表。例如，如果我们还是使用上面的两个表A和B，那么我们可以使用以下SQL语句来进行left join：

```sql
select A.id, A.name, B.age
from A
left join B
on A.id = B.id;
```

得到的结果是：

| id   | name | age  |
| :--- | :--- | :--- |
| 1    | a    | 10   |
| 2    | b    | 20   |
| 3    | c    | NULL |

可以看到，左表A中的所有记录都返回了，而右表B中只有id为1和2的记录匹配了连接条件，所以只返回这两条记录，id为3的记录没有匹配的记录，所以用NULL填充。

- right join是指返回右表中的所有记录，以及左表中满足连接条件的记录，如果左表中没有匹配的记录，则用NULL填充。也就是说，右表是主表，左表是从表。它和left join是对称的。例如，如果我们还是使用上面的两个表A和B，那么我们可以使用以下SQL语句来进行right join：

```sql
select A.id, A.name, B.age
from A
right join B
on A.id = B.id;
```

得到的结果是：

| id   | name | age  |
| :--- | :--- | :--- |
| 1    | a    | 10   |
| 2    | b    | 20   |
| NULL | NULL | 30   |

可以看到，右表B中的所有记录都返回了，而左表A中只有id为1和2的记录匹配了连接条件，所以只返回这两条记录，id为4的记录没有匹配的记录，所以用NULL填充。

- union是指将两个或多个查询结果合并成一个结果集，并且去除重复的记录。例如，如果我们有两个查询语句Q1和Q2，分别返回以下结果：

Q1:

| id   | name |
| :--- | :--- |
| 1    | a    |
| 2    | b    |

Q2:

| id   | name |
| :--- | :--- |
| 2    | b    |
| 3    | c    |

那么我们可以使用以下SQL语句来进行union：

```sql
select id, name from Q1
union
select id, name from Q2;
```

得到的结果是：

| id   | name |
| :--- | :--- |
| 1    | a    |
| 2    | b    |
| 3    | c    |

可以看到，两个查询结果中相同的记录（id为2）只返回了一次，而不同的记录都返回了。

## drop、turncate、delete 的区别

drop, truncate和delete都是SQL语句中常用的删除操作，用于将表中的数据进行清除或移除。它们的区别主要有以下几点：

- drop是一个数据定义语言（DDL）命令，用于删除整个表或数据库，包括表的结构和数据。使用drop命令后，表或数据库将不存在，无法恢复。
- truncate也是一个数据定义语言（DDL）命令，用于删除表中的所有数据，但保留表的结构。使用truncate命令后，表中的数据将被清空，但表的定义和索引等信息仍然存在。
- delete是一个数据操纵语言（DML）命令，用于删除表中的一部分或全部数据，但不影响表的结构。使用delete命令后，表中的数据将被移除，但表的定义和索引等信息仍然存在。

在性能上，drop是最快的，因为它只需要删除一次表或数据库的元数据信息；truncate次之，因为它只需要删除一次表中的所有数据；delete最慢，因为它需要逐行删除数据，并且可以使用where子句进行条件筛选。

在事务上，drop和truncate都是自动提交的，即执行后无法回滚；delete则可以回滚，因为它会记录每条删除的数据，并且可以使用事务控制语句进行提交或撤销。

在触发器上，drop和truncate都不会触发任何与表相关的触发器；delete则会触发与表相关的触发器，因为它会影响每条数据的状态。



## char 和 varchar 的区别，哪个索引效率更高？

char和varchar是两种常用的字符数据类型，它们在存储方式和性能上有一些不同。

char是固定长度的字符数据类型，也就是说，无论存储多少个字符，它都会占用定义的最大长度的空间。例如，如果定义一个char(10)的列，那么无论存储一个字符还是十个字符，它都会占用10个字节的空间。如果存储的字符数少于最大长度，那么它会用空格填充剩余的空间。

varchar是可变长度的字符数据类型，也就是说，它会根据实际存储的字符数动态分配空间。例如，如果定义一个varchar(10)的列，那么存储一个字符只会占用一个字节的空间，存储十个字符才会占用十个字节的空间。另外，varchar还需要额外的一个或两个字节来存储实际的字符数。

在索引效率上，char和varchar有以下几点影响：

- char由于是固定长度的，所以在字符串操作上比较简单和快速，不需要进行长度检查和转换。因此，在进行索引比较时，char通常比varchar更快。
- varchar由于是可变长度的，所以在字符串操作上比较复杂和慢速，需要进行长度检查和转换。因此，在进行索引比较时，varchar通常比char更慢。
- char由于可能会产生很多空格填充，所以在存储空间上比较浪费，导致索引文件变大，影响索引效率。
- varchar由于可以根据实际字符数节省空间，所以在存储空间上比较节省，导致索引文件变小，提高索引效率。

char和varchar对索引效率的影响取决于实际存储的数据和查询条件。一般来说，如果数据是固定长度或接近固定长度，并且需要进行频繁的索引比较，那么使用char可能更合适；如果数据是可变长度或差异很大，并且需要节省存储空间和提高查询速度，那么使用varchar可能更合适。

## datetime 和 timestamp 的区别

datetime和timestamp都是MySQL中常用的日期时间数据类型，它们在存储方式和功能上有一些不同

datetime是用于表示日期和时间的数据类型，它的格式是YYYY-MM-DD HH:MM:SS，它的支持范围是1000-01-01 00:00:00到9999-12-31 23:59:59。

datetime的特点是：

- 它可以存储任意的日期和时间，不受时区的影响。
- 它占用8个字节的存储空间，不管实际存储的值有多长。
- 它可以使用默认值或函数来赋值，例如DEFAULT CURRENT_TIMESTAMP或ON UPDATE CURRENT_TIMESTAMP。

timestamp也是用于表示日期和时间的数据类型，它的格式也是YYYY-MM-DD HH:MM:SS，但它的支持范围是1970-01-01 00:00:01 UTC到2038-01-19 03:14:07 UTC。

timestamp的特点是：

- 它实际上是存储一个从1970年1月1日开始的秒数，它会根据时区进行转换，显示为本地时间。
- 它占用4个字节的存储空间，比datetime更节省空间。
- 它会自动赋值为当前时间，如果没有指定值或指定为NULL。

datetime和timestamp在存储方式和功能上有以下几点区别：

- datetime可以存储更广泛的日期和时间范围，而timestamp只能存储有限的范围。
- datetime不受时区的影响，而timestamp会根据时区进行转换。
- datetime占用更多的存储空间，而timestamp占用更少的空间。
- datetime可以使用默认值或函数来赋值，而timestamp会自动赋值为当前时间。