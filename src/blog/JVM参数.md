---
title: JVM参数
order: 2
category:
  - Java面经
tag:
  - JVM
---

<AudioPlayer src="/sample.mp3" />

## JVM参数

最重要和常见的几个参数如下：

■ -Xms20m ：设置jvm初始化堆大小为20m，一般与-Xmx相同避免垃圾回收完成后jvm重新分。

■ -Xmx20m：设置jvm最大可用内存大小为20m。

■ -Xmn10m：设置新生代大小为20m。

■ -Xss128k：设置每个线程的栈大小为128k。

上面这几个参数我以前经常容易被混淆，不过后来根据字母拆分就简单了很多。

如下图：

![img](https://pic1.zhimg.com/80/v2-5acf2edfdf919ec7d4bda402e32b779c_1440w.webp)

## 你知道哪些 JVM 分析的工具

JVM 分析的工具有很多，它们可以帮助我们监控和调优 JVM 的性能、内存、垃圾回收、线程等方面。根据不同的功能和使用方式，可以分为以下几类：

- 命令行工具：这些工具是 JDK 自带的，可以在命令行中执行，不需要额外的安装或配置。比如 jps 可以查看 Java 进程的信息，jstack 可以查看线程的栈信息，jmap 可以查看堆内存的使用情况，jstat 可以查看 JVM 的统计信息等。
- 可视化工具：这些工具是基于图形界面的，可以提供更直观和丰富的监控和分析功能。比如 JConsole 可以查看 JVM 的概况、内存、线程、类加载和虚拟机信息，VisualVM 可以查看 JVM 的详细信息，并且支持插件扩展。
- 日志分析工具：这些工具是用来分析 JVM 生成的日志文件，比如 GC 日志，堆转储文件等。比如 GCViewer 可以解析 GC 日志，并生成 GC 的图表和报告]，GCeasy 可以在线分析 GC 日志，并提供优化建议。

## 发生 OOM 了如何排查？

#### 内存溢出

内存本身就太小，满足不了程序运行最小内存，则是内存溢出。

解决思路：直接加大内存。

#### 内存泄漏

观察内存，每一次gc后都有某一些不要的对象是gc不了的，一直占着空间，导致越来越多的对象堆积在内存中得不到释放，最终内存泄漏导致内存溢出。

解决思路：应该从代码层面进行解决，不需要的对象不要建立强引用。

### 工具的使用

### VisualVM

![image-20210924152842932](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5edbbdf7557e43a3ac0982773e4237d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

该软件可以看到jvm进程实时的cpu、堆、calssess、线程占用情况的变化

对于某一个时刻，也支持dump出文件进行分析

**一定要安装Visual GC插件，可以实时看到堆内存各个区域的变化**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f3bc4af54ec48ff980a7ee7526e9913~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

#### Jmap

Jmap是jdk自带的命令，支持对堆内存进行查看统计操作

例如：jmap -heap [pid]

![image-20210924153255105](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb2678700b1443978af39083de5f7be1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

可以看到每个区一共多少大，用了多少，还剩下多少

#### GC日志

```kotlin
kotlin复制代码 #GC后堆内存状态
 Heap after GC invocations=452 (full 18):
  def new generation   total 223104K, used 8553K [0x00000000c6200000, 0x00000000d5410000, 0x00000000d96a0000)
   eden space 198336K,   0% used [0x00000000c6200000, 0x00000000c6200000, 0x00000000d23b0000)
   from space 24768K,  34% used [0x00000000d3be0000, 0x00000000d443a670, 0x00000000d5410000)
   to   space 24768K,   0% used [0x00000000d23b0000, 0x00000000d23b0000, 0x00000000d3be0000)
  tenured generation   total 495616K, used 244951K [0x00000000d96a0000, 0x00000000f7aa0000, 0x0000000100000000)
    the space 495616K,  49% used [0x00000000d96a0000, 0x00000000e85d5e00, 0x00000000e85d5e00, 0x00000000f7aa0000)
  Metaspace       used 121936K, capacity 129174K, committed 132224K, reserved 1163264K
   class space    used 15581K, capacity 17393K, committed 18304K, reserved 1048576K
 }
 
 
 #GC前堆内存状态
 {Heap before GC invocations=452 (full 18):
  def new generation   total 223104K, used 206889K [0x00000000c6200000, 0x00000000d5410000, 0x00000000d96a0000)
   eden space 198336K, 100% used [0x00000000c6200000, 0x00000000d23b0000, 0x00000000d23b0000)
   from space 24768K,  34% used [0x00000000d3be0000, 0x00000000d443a670, 0x00000000d5410000)
   to   space 24768K,   0% used [0x00000000d23b0000, 0x00000000d23b0000, 0x00000000d3be0000)
  tenured generation   total 495616K, used 244951K [0x00000000d96a0000, 0x00000000f7aa0000, 0x0000000100000000)
    the space 495616K,  49% used [0x00000000d96a0000, 0x00000000e85d5e00, 0x00000000e85d5e00, 0x00000000f7aa0000)
  Metaspace       used 121983K, capacity 129174K, committed 132224K, reserved 1163264K
   class space    used 15582K, capacity 17393K, committed 18304K, reserved 1048576K
   
 #GC时间、[空间GC前后大小]、GC使用时间
 2021-09-24T15:32:35.319+0800: 3055.215: [GC (Allocation Failure) 2021-09-24T15:32:35.319+0800: 3055.215: [DefNew: 206889K->8627K(223104K), 0.0290467 secs] 451841K->253578K(718720K), 0.0291708 secs] [Times: user=0.02 sys=0.01, real=0.03 secs]
```

#### JVM参数

`-XX:+HeapDumpOnOutOfMemoryError`：出现oom时将堆dump下来

`-XX:HeapDumpPath=/app/heapdump.hprof`：dump文件存放位置

`-Dcom.sun.management.jmxremote.authenticate=false`：远程连接校验

`-Dcom.sun.management.jmxremote.ssl=false`：远程连接ssl方式

`-Dcom.sun.management.jmxremote.port=33306`：远程连接端口

`-XX:NewRatio`：年轻代和老年代大小比例，默认是2，即1：2

`-XX:MaxTenuringThreshold`：年轻代经过N次gc后还存活会进入老年代

###排查过程

1. 先确定是内存泄漏还是内存溢出

   - 由于项目执行任务时开始都是可以执行的，且并发执行多个任务都没有问题，而当任务执行多几次后，就会出现OOM
   - 观察每次GC后的堆内存空间，可以看到随着任务执行次数越来越多，GC执行后新生代能够清空，而老年代GC后的数据还是比较满的，则可以判定由于某些数据GC不掉，且该部分数据越来越多导致内存不足出现内存泄漏

2. 在一次full GC后dump出堆内存文件，查看占用大内存的对象的GCRoot，可以看到被一个static引用着，因此得不到释放。

   ![image-20210924162438661](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/07ec9689448d435ea5a656b48e804499~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

3. 最终可以确定是因为程序运行过程中一直往该static Map添加元素，而用完了不去清理掉，导致对象被该Map强引用，不会被GC掉，造成内存泄漏。

作者：奋斗扬[原文阅读](https://juejin.cn/post/7012153388431310884)

## 内存什么时候会出现锯齿状的波动，为什么会出现这种情况，举个例子？内存波形图是很小的锯齿形和很大的锯齿形比起来哪种好，为什么？波动很大怎么解决？

内存波动是指内存的使用率或者可用空间在一段时间内不断变化的现象。内存波动可能有以下几种原因：

- 内存泄漏：程序使用了内存，但是没有及时释放，导致内存资源不足，从而引起频繁的垃圾回收或者内存交换。
- 内存抖动：程序频繁地进行大量的内存分配和释放，导致内存碎片化，影响内存的使用效率和性能。
- 内存碎片：程序长时间运行后，内存中出现了很多不连续的空闲区域，导致无法分配给需要大块连续内存的程序，从而引起内存分配失败或者内存整理。
- 内存竞争：多个程序或者线程同时申请使用内存，导致内存的争用和冲突，从而影响内存的分配速度和效率。

举个例子，如果一个Java程序中有很多字符串拼接操作，每次拼接都会创建一个新的StringBuilder对象，这样就会产生大量的短暂的对象，占用了很多内存空间。当这些对象不再被引用时，就会被垃圾回收器回收，释放出内存空间。这样就会造成内存使用率忽高忽低，呈现锯齿状波动。

一般来说，内存波形图是很小的锯齿形比起来比较好，因为这说明内存波动比较平稳，没有太大的波动幅度和频率。如果波形图是很大的锯齿形，说明内存波动比较剧烈，可能会影响程序的运行速度和稳定性。波动很大可能会导致程序卡顿、延迟、崩溃等问题。

要解决内存波动很大的问题，可以采取以下一些措施：

- 避免或者减少内存泄漏：及时释放不再使用的对象或者资源，避免出现无法回收的引用。
- 避免或者减少内存抖动：尽量重用已有的对象或者资源，避免频繁创建和销毁对象。
- 避免或者减少内存碎片：尽量使用合适大小和数量的内存块，避免过大或者过小的内存分配。
- 避免或者减少内存竞争：尽量控制程序或者线程的数量和优先级，避免过多或者过高的内存请求。

## 在一个 for 循环中每次都需要 new 一个很大的对象，这一个对象就快把内存占满了，如果不想每次循环都发生 GC 该怎么办？

在一个 for 循环中每次都需要 new 一个很大的对象，这可能会导致内存占用过高，从而触发频繁的垃圾回收（GC）。如果不想每次循环都发生 GC，有以下几种方法可以尝试：

- 尽量复用对象，避免在循环中创建不必要的临时对象。如果对象的状态可以重置或者修改，可以考虑在循环结束后将其放入一个对象池中，下次需要时再从对象池中取出，而不是每次都 new 一个新的对象。
- 调整 JVM 的堆内存大小和 GC 算法，根据程序的特点选择合适的参数。例如，如果程序中有很多大对象，可以增加堆内存的大小，或者使用并行 GC 或 G1 GC 等能够处理大对象的算法。具体的 JVM 参数设置可以参考[这篇文章](https://zhuanlan.zhihu.com/p/25539690)。
- 使用一些性能监控工具，如 jstat、jstack、mat 等，来分析程序的内存使用情况和 GC 情况，找出内存泄漏或者内存消耗过高的地方，进行优化或者修复。具体的使用方法可以参考[这篇文章](https://www.cnblogs.com/javastack/p/12928208.html)。

## 线上 CPU 100% 怎么排查

线上 CPU 100% 是一个比较常见的性能问题，可能会导致系统运行缓慢，甚至崩溃。要排查这个问题，需要找出哪个进程或者哪个线程占用了过多的 CPU 资源，以及它们在执行什么操作。我为您搜索了一些相关的文章，您可以参考以下的步骤：

- 首先，使用 `top` 命令查看所有进程占系统 CPU 的排序。找出 CPU 使用率最高的进程，记下它的 PID（进程号）。
- 然后，使用 `top -Hp PID` 命令查看该进程下的所有线程占 CPU 的情况。找出 CPU 使用率最高的线程，记下它的 TID（线程号）。
- 接着，使用 `printf "%x\n" TID` 命令将线程号转换为十六进制的形式。这是因为 JVM 的工具会用十六进制表示线程号。
- 然后，使用 `jstack PID` 命令获取该进程的线程堆栈信息。使用 `grep` 命令或者文本编辑器查找十六进制的线程号，找到对应的线程堆栈信息。
- 最后，根据线程堆栈信息分析该线程在执行什么操作，是否有死循环、死锁、内存泄漏、垃圾回收、阻塞等情况导致 CPU 过高。