---
title: 招银网络一面0914
order: 2
category:
  - 每日一面
tag:
  - 每日一面
---

## java

### 集合都有什么（我回答的collection和map接口，以及下面的子接口和实现）

### hashmap怎么实现的？画一下结构

### 红黑树是什么样的结构？红黑树怎么自旋？

红黑树是一种自平衡的二叉查找树，它在计算机科学中被广泛使用，尤其是在数据结构如集合和映射中。红黑树能确保在插入、删除和查找操作中，最坏的情况下都能保持较好的搜索时间。

红黑树的名称来源于节点的颜色，可以是红色或黑色。红黑树满足以下性质：

1. 每个节点要么是红色，要么是黑色。
2. 根节点是黑色。
3. 所有叶子节点（NIL或空节点）是黑色。
4. 如果一个节点是红色，那么它的两个子节点都是黑色。
5. 对于每个节点，从该节点到其所有后代叶子节点的简单路径上，均包含相同数目的黑色节点。

为了维持这些性质，当执行插入或删除操作时，可能需要通过旋转和重新着色来调整树的结构。旋转是红黑树中的一个关键操作，它有两种：左旋和右旋。

1. **左旋（Left Rotate）**:
   设 x 为旋转前的根节点，y 为 x 的右子节点。左旋是将 x 降为 y 的左子节点，y 升为 x 的父节点，并处理其他子节点的关系，使得树的结构保持为二叉查找树。

   ```
   左旋操作：
   LEFT-ROTATE(T, x)
   1. y ← right[x]
   2. right[x] ← left[y]
   3. if left[y] ≠ NIL
   4.     parent[left[y]] ← x
   5. parent[y] ← parent[x]
   6. if parent[x] = NIL
   7.     root[T] ← y
   8. else if x = left[parent[x]]
   9.     left[parent[x]] ← y
   10. else right[parent[x]] ← y
   11. left[y] ← x
   12. parent[x] ← y
   ```

2. **右旋（Right Rotate）**:
   右旋与左旋相反，设 y 为旋转前的根节点，x 为 y 的左子节点。右旋是将 y 降为 x 的右子节点，x 升为 y 的父节点。

   ```
   右旋操作：
   RIGHT-ROTATE(T, y)
   1. x ← left[y]
   2. left[y] ← right[x]
   3. if right[x] ≠ NIL
   4.     parent[right[x]] ← y
   5. parent[x] ← parent[y]
   6. if parent[y] = NIL
   7.     root[T] ← x
   8. else if y = right[parent[y]]
   9.     right[parent[y]] ← x
   10. else left[parent[y]] ← x
   11. right[x] ← y
   12. parent[y] ← x
   ```

当插入或删除节点可能导致红黑树的性质被破坏时，通过旋转和重新着色来恢复这些性质。

### treemap怎么实现的？

`TreeMap` 是 Java 中的一个类，它实现了 `SortedMap` 接口，提供了基于红黑树的键值对的有序存储。由于它基于红黑树，所以它的主要操作（如 `get`, `put`, `remove`）的时间复杂度为 O(log n)。

以下是 `TreeMap` 的主要实现特点：

1. **内部结构**:
    - `TreeMap` 主要由内部的静态私有类 `Entry` 组成，这个类代表红黑树中的一个节点。每个 `Entry` 包含键、值、颜色（红或黑）以及指向左、右和父节点的指针。
    - `TreeMap` 还有一个指向红黑树根节点的指针。

2. **插入操作** (`put` 方法):
    - 当向 `TreeMap` 中插入一个新的键值对时，首先会按照二叉搜索树的规则找到合适的位置。
    - 插入后，为了保持红黑树的性质，可能需要进行一系列的颜色变更和旋转。

3. **删除操作** (`remove` 方法):
    - 删除操作首先会找到要删除的节点。
    - 如果要删除的节点有两个子节点，那么它会被其后继节点替代。
    - 删除后，为了保持红黑树的性质，可能需要进行一系列的颜色变更和旋转。

4. **查找操作** (`get` 方法):
    - 由于底层是二叉搜索树，所以查找操作会从根节点开始，根据键的大小向左或向右移动，直到找到匹配的键或达到叶子节点。

5. **有序性**:
    - 由于 `TreeMap` 实现了 `SortedMap` 接口，所以它提供了对键的有序访问。例如，`firstKey()`, `lastKey()`, `headMap()`, `tailMap()` 等方法都允许用户按照键的自然顺序或指定的比较器顺序访问键值对。

6. **比较器**:
    - `TreeMap` 可以接受一个比较器（`Comparator`），允许用户定义键的排序规则。如果没有提供比较器，那么键必须实现 `Comparable` 接口，并使用其自然顺序。

总的来说，`TreeMap` 的实现是基于红黑树的，这确保了其操作的高效性和键的有序性。

### treemap和hashmap线程安全的集合是什么？

在 Java 中，`TreeMap` 和 `HashMap` 都不是线程安全的。但是，Java 提供了一些工具和集合来确保线程安全性。

1. **对于 `HashMap`**:
    - **`Collections.synchronizedMap()`**: 你可以使用 `Collections.synchronizedMap()` 方法来包装 `HashMap`，使其变为线程安全。
      ```java
      Map<K, V> map = Collections.synchronizedMap(new HashMap<K, V>());
      ```
      当使用这种方式时，你需要确保 map 的所有迭代操作都是同步的。

    - **`ConcurrentHashMap`**: 这是一个线程安全的并发哈希映射实现。与使用 `synchronizedMap` 不同，`ConcurrentHashMap` 允许多个线程同时读取，而不需要锁定整个集合。这通常提供了更好的并发性能。
      ```java
      Map<K, V> concurrentMap = new ConcurrentHashMap<K, V>();
      ```

2. **对于 `TreeMap`**:
    - **`Collections.synchronizedSortedMap()`**: 你可以使用这个方法来包装 `TreeMap`，使其变为线程安全。
      ```java
      SortedMap<K, V> sortedMap = Collections.synchronizedSortedMap(new TreeMap<K, V>());
      ```
      和 `synchronizedMap` 一样，你需要确保 map 的所有迭代操作都是同步的。

    - 目前，Java 标准库中没有与 `ConcurrentHashMap` 相似的并发 `TreeMap` 实现。但是，你可以查找第三方库或使用其他并发数据结构，如 `ConcurrentSkipListMap`，它是一个线程安全的并发排序映射。

当你需要线程安全的集合时，选择哪种取决于你的具体需求。例如，如果你需要高并发性能并且不需要键的排序，那么 `ConcurrentHashMap` 可能是最佳选择。如果你需要键的排序，那么 `ConcurrentSkipListMap` 或同步的 `TreeMap` 可能更合适。

### 跳跃表有了解吗？画一下结构图。有什么是基于跳跃表实现的？

### hashmap可以使用跳跃表实现吗？（回答：可以但没必要。面试官直接笑了）

## 算法

### 图论中涉及的算法都有什么应用？（之前好像做过外卖配送订单调度的题，就说这个是应用。然后面试官让我写一下伪代码，这个怎么实现的，然后说我给自己出那么难的题。。结果就是我不会。。扯不出来）

## 线程

### 线程池怎么创建（回答了构造函数，包括里面的参数，还有executor创建）

### 怎么实现线程安全（锁、同步变量，aqs（纯纯给自己找罪受，背了一些，没想到那么深））

### 那你讲一下aqs怎么实现的（背了概念），后面问了啥忘了，反正有点难，没回答出来

## mysql

### java和mysql都有很多锁，mysql中的锁都有什么？（公平非公平啥的。还有记录锁，范围锁，next-key）

### 这些锁都是什么时候会被加上去？（不记得了，就记得排它锁加表锁，next-key会出现死锁）

在MySQL的InnoDB存储引擎中，`next-key`锁是一个组合锁，它包括一个记录锁（锁定索引记录本身）和一个间隙锁（锁定索引记录之间的间隙）。`next-key`锁的存在是为了解决幻读问题，确保在一个事务的生命周期内，其他事务不能插入新的记录到已经被锁定的间隙中。

然而，`next-key`锁也可能导致死锁。以下是一个简单的例子来说明为什么`next-key`锁可能导致死锁：

1. 假设我们有一个索引列，其中的值为1, 3, 5。
2. 事务A尝试更新值大于2的所有记录，因此它锁定了间隙(1,3)和记录3。
3. 同时，事务B尝试更新值大于4的所有记录，因此它锁定了间隙(3,5)和记录5。
4. 接下来，事务A尝试更新值大于4的所有记录，因此它试图锁定间隙(3,5)和记录5，但由于事务B已经锁定了这些，所以事务A被阻塞。
5. 同时，事务B尝试更新值大于2的所有记录，因此它试图锁定间隙(1,3)和记录3，但由于事务A已经锁定了这些，所以事务B也被阻塞。

在这个例子中，两个事务都在等待对方释放资源，形成了死锁。

为了避免这种情况，可以采取以下策略：

1. **按照固定的顺序访问数据**：如果所有事务都按照相同的顺序访问数据，那么死锁的可能性会大大减少。
2. **使用较低的隔离级别**：例如，读已提交（READ COMMITTED）隔离级别不会在非唯一索引上设置间隙锁，从而减少了死锁的可能性。
3. **设置锁超时时间**：可以设置较短的锁超时时间，这样当事务被阻塞时，它会在超时后自动回滚，从而解除死锁。
4. **使用死锁检测**：InnoDB有一个内置的死锁检测机制，当检测到死锁时，它会自动回滚其中一个事务，从而解除死锁。

总之，虽然`next-key`锁是为了解决幻读问题而引入的，但它也可能导致死锁。理解其工作原理并采取适当的策略可以帮助减少死锁的发生。

### 执行计划有了解吗（explain，以及返回的参数）

当你想要了解MySQL如何执行特定的SQL查询时，`EXPLAIN`命令是一个非常有用的工具。它为查询提供了一个执行计划，显示了MySQL如何使用索引和进行表扫描，从而帮助你优化查询性能。

当你在SQL查询前加上`EXPLAIN`关键字，MySQL会返回一个描述如何执行该查询的结果集。以下是`EXPLAIN`的一些常见输出列及其含义：

1. **id**：查询的标识符。如果是单个查询，ID通常为1。对于复杂的子查询或联接，每部分都有不同的ID。

2. **select_type**：查询的类型。常见的值有：
   - SIMPLE：简单的SELECT（不使用子查询或联接）。
   - PRIMARY：查询中最外层的SELECT。
   - SUBQUERY：在SELECT或WHERE中的子查询。
   - DERIVED：在FROM中的子查询。

3. **table**：输出行所引用的表。

4. **type**：连接类型。这是一个重要的字段，因为它显示了索引的使用情况。常见的值有：
   - system：表只有一行（等于const）。
   - const：通过常数值查找一行，这是最快的连接类型。
   - eq_ref：对于每个来自前一个表的行组合，从该表中读取一行。
   - ref：返回匹配某个单值的所有行。
   - range：通过索引键的范围来检索行。
   - index：全索引扫描。
   - ALL：全表扫描，没有使用索引。

5. **possible_keys**：可能使用的索引。

6. **key**：实际使用的索引。

7. **key_len**：使用的索引的长度。在不使用索引的情况下为NULL。

8. **ref**：显示了哪些列或常量被用作索引查找的键值。

9. **rows**：MySQL认为必须检查的行数。

10. **Extra**：关于查询的其他信息。常见的值有：
   - Using where：使用了WHERE从句来过滤结果。
   - Using index：只使用了索引来从表中获取数据，没有实际地读取表的行。
   - Using filesort：需要额外的排序步骤。
   - Using temporary：使用了临时表来存储中间结果。

使用`EXPLAIN`可以帮助你识别查询中的瓶颈，例如不必要的全表扫描或不恰当的索引使用。通过理解和分析`EXPLAIN`的输出，你可以对查询进行优化，从而提高性能。

那返回的参数，比如extra都有什么？扒拉扒拉。。

然后extra返回的参数根据性能排个序。

都是什么情况会返回这个参数？

## spring

面试官问的是你熟悉什么开源框架（说的spring，面到这里已经是感觉g的不能再g了，说完spring我就笑了，因为当时感觉是面试官让我找个熟悉的）

spring是怎么加载的，注解啦，加载过程，怎么调用的说一下（问完心态崩了，只记得啥componentscan，configuration，beann啥的加载）

问我spring中的设计模式，工厂模式都有什么？让我画工厂模式的结构图（什么继承什么，什么实现什么的）