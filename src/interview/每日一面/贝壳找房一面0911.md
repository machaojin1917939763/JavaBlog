---
title: 贝壳找房一面0911
order: 2
category:
  - 每日一面
tag:
  - 每日一面
---

## 1.自我介绍

### 2.项目经历

### 3.知道哪些消息队列？Kafka如何保证消息顺序？延时队列的原理？

### RabbitMQ

RabbitMQ 提供了消息的 TTL (Time-To-Live) 设置，允许你为消息设置一个过期时间。一旦消息在队列中存活的时间超过了这个设置的时间，它就会被标记为过期并从队列中移除。以下是 RabbitMQ 中消息过期的基本原理和使用方法：

1. **消息级别的 TTL**：
   - 当发布消息时，你可以为每个消息设置一个 `expiration` 属性，这个属性的值是以毫秒为单位的。
   - 如果消息在队列中的存活时间超过了这个设置的时间，它就会被移除。
   - 例如，使用 RabbitMQ 的 AMQP 客户端库，你可以这样设置消息的 TTL：
     ```python
     channel.basic_publish(exchange='',
                           routing_key='my_queue',
                           body='Hello World!',
                           properties=pika.BasicProperties(
                               expiration='10000'  # 10 seconds
                           ))
     ```

2. **队列级别的 TTL**：
   - 你可以为整个队列设置一个 TTL 值。这意味着队列中的所有消息都有相同的过期时间。
   - 如果队列中的消息超过了这个时间，它们会被移除。
   - 注意：队列级别的 TTL 会覆盖消息级别的 TTL。
   - 设置队列的 TTL 时，可以使用 `x-message-ttl` 参数：
     ```python
     args = {"x-message-ttl": 10000}  # 10 seconds
     channel.queue_declare(queue='my_queue', arguments=args)
     ```

3. **过期的行为**：
   - 当消息过期时，RabbitMQ 会从队列中移除它。这个过程是在消息即将被消费时进行的，而不是在消息实际过期的那一刻。
   - 过期的消息不会被发送到消费者。
   - 如果你有一个死信交换器 (DLX) 的设置，过期的消息会被发送到 DLX。

4. **注意事项**：
   - 如果队列中的消息因为其他原因（如队列达到最大长度）被移除，它们可能会在实际过期之前被移除。
   - 设置了 TTL 的消息在持久化到磁盘之前会被检查其过期状态。如果消息已经过期，它不会被写入磁盘。

RabbitMQ 提供了灵活的消息过期机制，允许你根据应用程序的需求设置消息的生存时间。

## RocketMQ

RocketMQ 是阿里巴巴开源的一个分布式消息中间件。它支持延时消息，即消息不会立即被消费，而是在指定的延迟时间后才能被消费。以下是 RocketMQ 延时队列的基本原理：

1. **延时级别**：
   - RocketMQ 不允许用户自定义任意的延迟时间，而是提供了预定义的几个延迟级别。例如，1s、5s、10s、30s、1m、2m、3m 等。
   - 当发送消息时，用户可以选择其中的一个延迟级别。

2. **延时设计**：
   - 当消息被发送为延时消息时，它首先会被存储在主题队列中，但不会立即被消费。
   - RocketMQ 会为每个延迟级别维护一个“延时队列”。这不是真正的物理队列，而是一个调度机制。
   - 消息在主题队列中的消费进度是由消费者的消费进度决定的，而延时队列中的消费进度是由时间决定的。
   - 当延时时间到达时，延时队列中的消息会被“释放”到主题队列中，此时消费者可以消费这些消息。

3. **实现细节**：
   - RocketMQ 的延时队列实际上是使用了一个定时任务来检查每个延迟级别的队列。
   - 当定时任务发现某个延迟级别的时间已经到达，它会将这个延迟级别的队列中的消息转移到主题队列中。
   - 为了提高效率，RocketMQ 使用了一个跳表（SkipList）结构来存储和检索延时消息。

4. **注意事项**：
   - 由于 RocketMQ 的延迟消息是基于预定义的延迟级别的，所以它可能不适合需要精确延迟时间的场景。
   - RocketMQ 的延迟消息并不保证消息在延迟时间到达后立即被消费，但它确保消息不会在延迟时间之前被消费。

RocketMQ 的延时队列是通过预定义的延迟级别、定时任务和跳表结构来实现的。这种设计旨在提供一个高效、可靠的延迟消息机制。

### 3.索引及其数据结构，说说最左前缀匹配

索引是数据库中用于提高查询速度的数据结构。通过使用索引，我们可以避免扫描整个表来查找数据，从而大大提高查询效率。以下是关于索引和其数据结构的简要说明：

### 1. 索引的数据结构：

- **B树 (Balanced Tree)**：B树是一种自平衡的树结构，它保持数据有序并允许查找、顺序访问、插入和删除在对数时间内完成。B树的每个节点可以有多个孩子，节点的数量通常在预定的范围内。

- **B+树**：B+树是B树的一种变体，它的所有值都出现在叶子节点，并且叶子节点是通过指针连接的，这使得范围查询更加高效。大多数关系型数据库的索引（如 MySQL 的 InnoDB 存储引擎）使用 B+树。

- **哈希索引**：哈希索引基于哈希表，它为每个唯一键值提供一个指针。哈希索引非常适合等值查询，但不适合范围查询。

- **位图索引**：位图索引使用位向量来表示数据集中的某个特定属性的存在。它特别适用于有大量重复值的列。

### 2. 最左前缀匹配：

最左前缀匹配原则是指在使用复合索引进行查询时，查询条件必须使用索引的最左边的一列或连续的多列。换句话说，如果查询没有使用索引的最左列，那么该索引将不会被使用。

例如，假设我们有一个复合索引 `(A, B, C)`，以下查询会使用索引：

- `WHERE A = ...`
- `WHERE A = ... AND B = ...`
- `WHERE A = ... AND B = ... AND C = ...`

但以下查询则不会使用索引（或者只部分使用）：

- `WHERE B = ...`（没有使用最左列 A）
- `WHERE B = ... AND C = ...`（没有使用最左列 A）
- `WHERE A = ... AND C = ...`（虽然使用了最左列 A，但没有连续使用 B）

了解最左前缀匹配原则对于编写高效的 SQL 查询和正确地设计索引是非常重要的。

总之，索引是一种优化数据库查询性能的数据结构，它可以基于多种数据结构实现。在使用复合索引时，最左前缀匹配原则是一个关键的概念，它决定了索引是否会被查询使用。

### 4.事务隔离级别，如何避免幻读？

### 5.MVCC的流程

MVCC（多版本并发控制）是一种用于控制多个事务并发执行时的数据一致性的技术。在 MySQL 中，InnoDB 存储引擎使用 MVCC 来实现事务的隔离性和非锁定读取，从而提高并发性能。

以下是 MySQL 中 MVCC 的基本流程和工作原理：

1. **版本控制**：
   - 每行数据在 InnoDB 中都有两个隐藏的列：创建版本号和删除版本号。这些版本号对应于系统版本号，系统版本号是一个递增的数字，每开始一个新的事务，它就会增加。
   - 当事务插入一行数据时，该行的创建版本号被设置为该事务的系统版本号。
   - 当事务删除一行数据时，该行的删除版本号被设置为该事务的系统版本号。

2. **读操作**：
   - 当事务尝试读取一行数据时，它会检查该行的创建版本号和删除版本号来确定该行的可见性。
   - 如果行的创建版本号大于事务的系统版本号，或者行的删除版本号小于等于事务的系统版本号并且不为 NULL，那么该行对于该事务是不可见的。
   - 否则，该行对于该事务是可见的。

3. **写操作**：
   - 当事务尝试更新一行数据时，InnoDB 不会直接覆盖原始数据。相反，它会插入一个新的版本，并更新原始行的删除版本号。
   - 这意味着同一行数据在数据库中可能有多个版本。每个版本都对应于不同的事务。

4. **事务提交**：
   - 当事务提交时，它的修改会被永久保存，系统版本号会增加。
   - 未提交的事务不会影响其他事务的读写操作，因为每个事务都在其自己的快照版本上工作。

5. **垃圾收集**：
   - 随着时间的推移，某些行版本可能不再被任何事务引用。这些旧版本会被 InnoDB 的垃圾收集机制清除，以释放空间。

6. **隔离级别**：
   - MVCC 支持多种事务隔离级别。在不同的隔离级别下，事务对数据的可见性和并发控制有所不同。
   - 例如，在 READ COMMITTED 隔离级别下，事务每次读取都会看到最新提交的数据。而在 REPEATABLE READ 隔离级别下，事务始终看到它开始时的数据快照。

MVCC 通过为数据的每个版本维护创建和删除版本号，允许多个事务并发访问数据，而不需要加锁。这大大提高了数据库的并发性能，同时确保了数据的一致性和隔离性。

### 6.Redis为什么这么快？

### 7.Java为什么能够跨平台？

### 8.String、StringBuilder与StringBuffer的区别，StringBuffer为什么线程安全？

### 9.Sychronized底层原理，锁优化

### 10.Redis分布锁有自己实现过吗？过期时间一般设多久？

### 11.Spring的事务失效场景

Spring 提供了一个强大的声明式事务管理能力，但在某些情况下，你可能会发现事务并没有如预期那样工作，即事务失效。以下是一些常见的 Spring 事务失效场景及其原因：

1. **方法访问级别**：
   - 默认情况下，Spring 的 AOP 事务只能拦截 public 方法。如果你在一个类内部调用另一个非 public 的带有 `@Transactional` 注解的方法，事务是不会起作用的。

2. **自调用问题**：
   - 如果一个类中的一个方法调用同一个类中的另一个带有 `@Transactional` 注解的方法，事务是不会起作用的。这是因为事务是通过代理实现的，而自调用会绕过代理。

3. **异常类型**：
   - 默认情况下，只有在运行时异常（即，继承自 `RuntimeException` 的异常）被抛出时，事务才会回滚。如果一个方法抛出的是检查型异常（checked exception），事务不会回滚，除非你明确指定。

4. **事务传播行为**：
   - 如果你不正确地配置事务的传播行为（如 `Propagation.REQUIRED`、`Propagation.REQUIRES_NEW` 等），可能会导致事务不如预期地工作。

5. **数据库不支持事务**：
   - 不是所有的数据库都支持事务。如果你使用的数据库或数据库引擎（如 MySQL 的 MyISAM 引擎）不支持事务，那么事务管理自然是无效的。

6. **只读事务**：
   - 如果你将事务标记为只读，例如 `@Transactional(readOnly=true)`，那么任何修改数据库的操作都不会被提交。

7. **事务超时**：
   - 如果你为事务设置了超时时间，而事务的执行时间超过了这个时间，那么事务会被回滚。

8. **不正确的事务管理器配置**：
   - 如果你在 Spring 配置中不正确地配置了事务管理器，或者在多数据源的情况下没有为特定的操作指定正确的事务管理器，事务可能不会起作用。

9. **没有启用事务注解**：
   - 如果你忘记在 Spring 配置中添加 `<tx:annotation-driven />` 或 `@EnableTransactionManagement`，事务注解将不会被识别，从而导致事务失效。

10. **事务嵌套**：
   - 如果你在一个事务方法中调用另一个事务方法，并且配置了不兼容的传播行为，可能会导致不如预期的事务行为。

为了避免上述问题，你应该确保正确地理解和配置 Spring 的事务管理功能，并在开发过程中进行充分的测试。

### 12.手撕：leetcode简单题