---
title: 招银网络一面0912
order: 2
category:
  - 每日一面
tag:
  - 每日一面
---

## 1.介绍concurrentHashmap底层结构、CAS是什么、如何解决ABA问题

### ConcurrentHashMap 的底层结构

#### 1. **数组**

`ConcurrentHashMap` 的核心是一个 Node<K,V>[] 的数组。当数组的某个元素为空时，可以通过 CAS 操作直接插入新节点。但当多个线程同时尝试在同一位置插入时，就可能会有冲突。

#### 2. **链表**

为了解决哈希冲突的问题，每个数组的槽(slot)不仅仅存储一个元素，而是一个链表。当多个元素的哈希值映射到同一个槽时，它们会被放在同一个链表中。

#### 3. **红黑树**

从 Java 8 开始，为了提高性能，当链表的长度超过一定的阈值（默认为 8）时，链表会被转换为红黑树。红黑树是一种自平衡的二叉搜索树，它可以确保查找、插入和删除的时间复杂度为 O(log n)，这比长链表的 O(n) 要好得多。当红黑树的大小减少到一定程度时（默认为 6），它会再次退化为链表。

### 并发控制

#### 1. **分段锁（Java 7 及之前）**

在 Java 7 及之前，`ConcurrentHashMap` 使用了一种分段锁的策略。整个 map 被分为多个段(segment)，每个段都有自己的锁。这意味着多个线程可以同时写入 map，只要它们写入的是不同的段。这大大提高了并发性能。

#### 2. **synchronized + CAS（Java 8 及之后）**

从 Java 8 开始，`ConcurrentHashMap` 的实现放弃了分段锁的设计，转而使用节点级的 synchronized 锁加上 CAS 操作来保证并发安全性。这种设计在高并发环境下提供了更好的性能。

### 其他特性

- **resize**: 当 map 中的元素数量超过数组的一定比例（负载因子，默认为 0.75）时，数组会进行扩容，即 resize。这个操作也是线程安全的。
- **计算视图**: Java 8 引入了一些新的功能，如 `compute()`, `computeIfAbsent()`, 和 `computeIfPresent()`，这些方法允许原子性地计算或重新计算键值对。

## 2.redis持久化方式、如何与数据库保持数据一致

Redis 是一个内存中的数据结构存储系统，但为了确保数据的持久性，它提供了几种持久化机制。以下是 Redis 的主要持久化方式：

### 1. RDB (Redis DataBase)

- **描述**：RDB 持久化方式是通过创建数据集的二进制快照来实现的。
  
- **触发方式**：
  - 定时：可以配置 Redis 在 n 秒内如果超过 m 次修改就自动保存。
  - 手动：使用 `SAVE` 或 `BGSAVE` 命令。
  
- **优点**：
  - 生成的 RDB 文件非常紧凑，适合做数据备份或者数据迁移。
  - 恢复大数据集时的速度比 AOF 快。
  
- **缺点**：
  - 如果 Redis 未能正常关闭，你可能会丢失最后一次快照后的所有修改。
  - 对于大数据集，快照可能会阻塞服务器。

### 2. AOF (Append Only File)

- **描述**：AOF 持久化方式记录服务器接收到的所有写操作，并在服务器启动时重新执行这些命令来恢复数据。

- **触发方式**：每当执行一个写命令时，Redis 就将该命令写入 AOF 文件。

- **优点**：
  - 通常比 RDB 更安全，可以配置不同的 fsync 策略，如每秒同步或每次写入同步。
  - AOF 文件是一个只追加文件，即使文件被截断或损坏，也可以轻松修复。
  
- **缺点**：
  - 根据 fsync 策略，AOF 可能比 RDB 慢。
  - AOF 文件可能会比 RDB 文件大很多。

### 3. 混合持久化

从 Redis 4.0 开始，可以同时使用 RDB 和 AOF。当 Redis 重启时，它会使用 RDB 来快速重建数据集，然后使用 AOF 文件中的命令来重放自上次 RDB 快照以来的写操作，这样可以结合 RDB 和 AOF 的优点。

### 如何与数据库保持数据一致？

双写模式

只写数据库，删除缓存

延时双删（主流做法）

先写缓存再写数据库

canal监听MYSQL binlog日志

## 3.jvm内存区域、堆的分区、新生代老生代如何垃圾回收的

### JVM 内存区域

Java 虚拟机（JVM）的内存可以划分为以下几个主要区域：

1. **方法区（Method Area）**：存储已被 JVM 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

2. **堆（Heap）**：JVM 所管理的最大一块内存区域，主要用于存放对象实例。它被划分为新生代和老年代。

3. **虚拟机栈（VM Stack）**：每个线程都有一个私有的栈，它存储了一个方法执行的局部变量、动态链接、返回地址等信息。

4. **本地方法栈（Native Method Stack）**：与虚拟机栈类似，但是为 JVM 使用的 Native 方法服务。

5. **程序计数器（Program Counter Register）**：每个线程都有一个私有的计数器，记录正在执行的 JVM 指令地址。

### 堆的分区

堆主要分为两个区域：新生代和老年代。

1. **新生代（Young Generation）**：新生代又可以分为三个部分：
   - **Eden 区**：大部分新创建的对象首先被分配到 Eden 区。
   - **Survivor 区**：包括两个部分，S0 和 S1。每次垃圾回收后，存活的对象会被移动到其中一个 Survivor 区，而另一个 Survivor 区此时是空的。

2. **老年代（Old Generation）**：长时间存活的对象或新生代中经过多次垃圾回收仍然存活的对象会被移动到老年代。

### 垃圾回收

1. **新生代的垃圾回收**：
   - 通常使用 **Minor GC**（或 Young GC）来清理新生代。
   - 回收过程中，首先清除 Eden 区，然后将存活的对象移动到一个 Survivor 区（例如 S0），而之前的 Survivor 区（例如 S1）中的对象如果仍然存活则移动到另一个 Survivor 区或老年代。
   - 新生代通常采用复制算法进行垃圾回收，因为新生代中的对象大多数都是“朝生夕死”的，所以复制算法在这里更加高效。

2. **老年代的垃圾回收**：
   - 老年代的垃圾回收称为 **Major GC** 或 **Full GC**。这种回收会涉及整个堆，包括新生代和老年代，因此它的停顿时间通常比 Minor GC 长。
   - 老年代通常使用标记-清除-整理（Mark-Sweep-Compact）算法进行垃圾回收。

### 注意

- **频繁的 Minor GC**：由于新生代空间相对较小，所以 Minor GC 会比较频繁。
  
- **Full GC 的停顿**：Full GC 由于涉及整个堆，所以停顿时间会比较长。频繁的 Full GC 通常是一个性能问题，可能需要调整 JVM 参数或检查应用程序来解决。

- **垃圾回收器**：JVM 提供了多种垃圾回收器，如 Parallel、CMS、G1 等，每种回收器都有其特点和使用场景。

JVM 的内存管理和垃圾回收是确保 Java 应用程序高效运行的关键组件。理解其工作原理和特点可以帮助开发者更好地优化应用程序和解决性能问题。

### 历代垃圾回收器

Java 开发工具包 (JDK) 中的垃圾回收器 (GC) 在各个版本中都有所发展。以下是 JDK 历代的主要垃圾回收器：

### 1. **Serial GC**
- **描述**：这是最基本的 GC，使用单线程进行垃圾回收。它会暂停所有的工作线程（Stop-The-World）来进行垃圾回收。
- **适用场景**：单线程应用或者小内存需求的应用。

### 2. **Parallel GC (或 Throughput Collector)**
- **描述**：多线程版本的 Serial GC。它在新生代使用复制算法，在老年代使用标记-清除-整理算法。
- **适用场景**：多线程应用，追求吞吐量。

### 3. **CMS (Concurrent Mark-Sweep) Collector**
- **描述**：以获取最短回收停顿时间为目标的收集器。它在标记和清除阶段的大部分工作都与应用线程并发执行，但这可能会导致一些碎片。
- **适用场景**：注重服务响应时间的应用。

### 4. **G1 (Garbage-First) Collector**
- **描述**：旨在替代 CMS 的收集器，它将堆划分为多个小块（region），可以并发地进行垃圾回收。G1 旨在与应用线程并发执行，并提供更可预测的停顿时间。
- **适用场景**：大内存系统，需要限制 GC 停顿时间。

### 5. **ZGC (Z Garbage Collector)**
- **描述**：JDK 11 中引入的低延迟垃圾收集器。ZGC 几乎可以消除所有 GC 停顿时间，无论堆大小如何。
- **适用场景**：需要极低停顿时间的大内存应用。

### 6. **Shenandoah GC**
- **描述**：与 ZGC 类似，Shenandoah 也是一个低延迟的垃圾收集器，它的目标是实现高吞吐量和可预测的停顿。
- **适用场景**：需要低延迟和高吞吐量的应用。

### 7. **Epsilon GC**
- **描述**：JEP 318 中引入的一个非常特殊的垃圾收集器，它实际上不进行任何垃圾回收。当堆内存用完时，应用程序会崩溃。
- **适用场景**：短生命周期的任务，或者测试和性能基准。

以上是 JDK 历代的主要垃圾回收器。每种 GC 都有其特点和适用场景，选择合适的 GC 可以根据应用的需求和特点来决定。

### 首次出现的JDK版本

1. **Serial GC**
   - **首次出现版本**：JDK 1.3

2. **Parallel GC (或 Throughput Collector)**
   - **首次出现版本**：JDK 1.4

3. **CMS (Concurrent Mark-Sweep) Collector**
   - **首次出现版本**：JDK 1.4.2

4. **G1 (Garbage-First) Collector**
   - **首次出现版本**：JDK 7 (但直到 JDK 9，G1 才成为默认的垃圾回收器)

5. **ZGC (Z Garbage Collector)**
   - **首次出现版本**：JDK 11

6. **Shenandoah GC**
   - **首次出现版本**：JDK 12 (但请注意，Shenandoah 最初是作为 OpenJDK 的一个补丁存在的，后来被纳入主分支)

7. **Epsilon GC**
   - **首次出现版本**：JDK 11

## 4.url显示主页的过程、tcp为什么不能只两次握手

下面主要是从ISO七层模型上面来回答的：

### 1. **应用层 (Application Layer)**
- **浏览器请求**：当你输入 URL 并按下 Enter 键，浏览器准备发起一个请求，首先会检查浏览器中是否有缓存。
- **DNS 解析**：浏览器首先需要知道目标服务器的 IP 地址。它会查找本地缓存或者请求 DNS 服务器来解析域名对应的 IP 地址。这可能涉及多个 DNS 服务器，从本地的 DNS 服务器到根域名服务器，再到顶级域名服务器，最后到权威 DNS 服务器。
- **HTTP/HTTPS**：浏览器使用 HTTP 或 HTTPS 协议与服务器通信，请求网页内容。

### 2. **表示层 (Presentation Layer)**
- **加密/解密**：如果使用 HTTPS，数据会在这一层被加密，确保数据传输的安全性。

### 3. **会话层 (Session Layer)**
- 管理两台计算机之间的会话，确保数据的连续性。

### 4. **传输层 (Transport Layer)**
- **TCP 三次握手**：浏览器与服务器之间的通信基于 TCP 协议。浏览器会与服务器进行三次握手来建立一个 TCP 连接。

### 5. **网络层 (Network Layer)**
- **IP 路由**：数据包会被路由到目标服务器的 IP 地址。

### 6. **数据链路层 (Data Link Layer)**
- **ARP (Address Resolution Protocol)**：当你的计算机知道了目标 IP 地址后，它需要知道对应的 MAC 地址才能在局域网内进行通信。ARP 用于解析 IP 地址到 MAC 地址。
- **数据帧传输**：数据在这一层被封装为帧，并进行物理传输。

### 7. **物理层 (Physical Layer)**
- **数据传输**：这一层涉及到实际的硬件设备、电缆、交换机等。当你的计算机发送或接收数据时，数据会在这一层以电信号或光信号的形式传输。

### 服务器处理和响应

- 服务器接收到 HTTP 请求后，交给相应的服务器软件处理（如 Apache、Nginx、Tomcat 等）。
- 服务器可能需要查询数据库、与其他服务交互、处理服务器端的逻辑或执行其他操作来准备响应数据。
- 服务器将准备好的数据（通常是 HTML、CSS、JavaScript、图片等）作为 HTTP 响应返回给浏览器。

### 页面渲染
- 浏览器开始解析返回的 HTML。
- 解析过程中，浏览器可能会发现需要额外的资源，如 CSS、JavaScript、图片等。对于这些资源，浏览器会再次发起请求。
- 浏览器会执行 JavaScript，这可能会改变页面的内容或结构。
- 浏览器使用 HTML 和 CSS 渲染页面。

### TCP 为什么不能只两次握手

TCP 使用三次握手（Three-way Handshake）来建立连接，而不是两次，主要有以下原因：

1. **确保双方都准备好**：三次握手确保了双方都有发送和接收消息的能力。在三次握手过程中，客户端和服务器都发送了 SYN 和 ACK，这证明了双方都能发送和接收。
2. **避免已失效的连接请求突然到来**：如果只有两次握手，那么旧的、延迟的连接请求可能会导致不必要的连接建立。考虑这样一个场景：客户端发送了一个连接请求，但因为网络问题它被延迟了。客户端超时后重新发送了连接请求并建立了连接。如果旧的连接请求突然到达服务器，服务器可能会错误地认为这是一个新的连接请求。
3. **初始化序列号**：TCP 使用序列号来标识每个字节，这确保了数据的完整性和顺序。三次握手过程中的 SYN 消息允许双方交换并确认初始的序列号。

## 5.内存溢出和内存泄漏的区别、有遇到内存泄漏吗怎么处理的

### 内存溢出与内存泄漏的区别：

1. **内存溢出 (Memory Overflow)**:
   - 描述：当程序尝试使用超过其分配的内存时，会发生内存溢出。简单地说，当程序需要的内存超过了可用内存时，就会发生内存溢出。
   - 结果：通常会导致程序崩溃或异常。
   - 例子：在 Java 中，当堆内存或栈内存用尽时，可能会抛出 `OutOfMemoryError`。

2. **内存泄漏 (Memory Leak)**:
   - 描述：当程序中的对象不再使用，但仍然被引用，从而导致无法被垃圾回收器回收的情况，称为内存泄漏。随着时间的推移，这些未回收的对象会逐渐积累，最终可能导致内存溢出。
   - 结果：长时间运行的程序可能会变得越来越慢，最终可能导致内存溢出。
   - 例子：在 Java 中，长时间运行的应用可能会因为持有过期引用而导致内存泄漏。

### 遇到内存泄漏时的处理方法：

1. **识别内存泄漏**：
   - 使用性能分析工具（如 Java 的 VisualVM、YourKit、MAT 等）来监控应用程序的内存使用情况。
   - 对于 Web 应用，检查是否有大量的会话数据未被释放。
   - 检查代码中是否有长时间持有的对象，特别是在集合中。

2. **修复内存泄漏**：
   - 一旦确定了内存泄漏的来源，修复通常涉及到删除不再使用的对象的引用，使其可以被垃圾回收。
   - 在 Java 中，确保关闭资源，如数据库连接、文件流等。
   - 通常使用软引用 (`SoftReference`) 或弱引用 (`WeakReference`) 来持有
   - 它们的区别和使用场景如下：
   
     1. **弱引用 (`WeakReference`)**：
        - 当一个对象只被弱引用引用时，它会在下一次垃圾回收时被回收。
        - 弱引用通常用于实现如缓存等功能，当你想要保存一个对象，但不想阻止它被垃圾回收时，可以使用弱引用。
     2. **软引用 (`SoftReference`)**：
        - 软引用比弱引用的生命周期要长。当一个对象只被软引用引用，并且内存足够时，它不会被垃圾回收；但当 JVM 内存不足时，这些对象会被回收。
        - 软引用通常用于实现内存敏感的缓存。当你想要保存一个对象，并且希望它在内存紧张时被回收，可以使用软引用。
   
     对于防止内存泄漏，弱引用是更常用的选择，因为它确保了对象可以在不再需要时被及时回收。而软引用更多地是用于那些你希望在内存紧张时才被回收的对象。
   
3. **代码审查**：
   
   - 定期进行代码审查，特别是对于那些处理资源或长时间运行的代码。
   - 使用静态代码分析工具来检测可能的内存泄漏。
   
4. **测试**：
   - 对于关键应用，进行压力测试和长时间运行测试，以确保没有内存泄漏。
   - 使用自动化测试工具来模拟真实的使用情况，并监控内存使用情况。

总的来说，内存泄漏可能是难以发现的问题，但使用正确的工具和方法可以帮助开发者定位和修复这些问题。

## 6.场景：给一个用户信息如何存储到数据库

## 7.String中==和equals的区别，String可变吗？可重写吗？

## 8.Spring AOP、动态代理类型

## 9.有Springboot为什么要用Springcloud？Springcloud的组件、最新版本的注册中心

### 为什么在有 Spring Boot 的情况下还要使用 Spring Cloud？

1. **微服务架构**：Spring Boot 是一个快速开发单体应用或微服务的工具，而 Spring Cloud 提供了一整套微服务的解决方案，包括服务注册与发现、配置中心、API 网关、服务熔断、负载均衡、链路追踪等。

2. **分布式系统的复杂性**：当你开始开发分布式系统或微服务，你会遇到许多复杂的问题，如配置管理、服务发现、断路器、智能路由、微代理、控制总线等。Spring Cloud 提供了处理这些问题的工具。

3. **开箱即用**：Spring Cloud 基于 Spring Boot，这意味着它继承了 Spring Boot 的所有特性，如自动配置、健康检查等，并为微服务提供了额外的功能。

### Spring Cloud 的主要组件：

1. **Spring Cloud Config**：为微服务应用提供集中化的外部配置支持。
2. **Spring Cloud Netflix**：包括多个子项目，如 Eureka (服务注册与发现)、Hystrix (断路器)、Zuul (API 网关)、Ribbon (客户端负载均衡) 等。
3. **Spring Cloud Gateway**：API 网关，用于请求路由、API 组合等。
4. **Spring Cloud Bus**：用于传播配置文件的更改或其他管理指令，可以与 Spring Cloud Config 配合使用。
5. **Spring Cloud Sleuth**：用于微服务的链路追踪。
6. **Spring Cloud Stream**：为微服务应用构建消息驱动的能力。
7. **Spring Cloud Security**：在微服务之间添加安全控制。
8. **Spring Cloud Consul**：整合了 Consul 服务发现与配置。
9. **Spring Cloud Zookeeper**：整合了 Zookeeper 服务发现与配置。

### 最新版本的注册中心：

Spring Cloud 的生态系统中有多个服务注册中心的实现，包括：

1. **Eureka**：Netflix 开源的服务注册与发现组件，长时间是 Spring Cloud 生态系统中的默认选择。
2. **Consul**：HashiCorp 开源的工具，提供服务发现和配置。
3. **Zookeeper**：Apache 的分布式协调服务，也可以用作服务注册与发现。
4. **Nacos**：来自 Alibaba，是一个更现代的、易于管理的服务注册与发现解决方案。

随着时间的推移，Eureka 的开发已经变得相对缓慢，而其他解决方案，如 Consul 和 Nacos，正在变得越来越受欢迎。选择哪一个取决于你的具体需求和团队的熟悉度。

## 10.mysql的默认隔离级别、解决了什么问题、如何解决幻读的、mvcc是如何解决幻读的、垂直分表、水平分表

## 11.linux常用命令、linux设置权限命令、777

## 手撕：单例模式

