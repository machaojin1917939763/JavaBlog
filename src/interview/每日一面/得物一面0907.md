---
title: 得物一面0907
order: 2
category:
  - 每日一面
tag:
  - 每日一面
---

## 1.手撕约瑟夫环

约瑟夫环（Josephus Problem）是一个著名的数学和计算机问题。问题的背景是这样的：

在古代犹太历史上，有一个叫做约瑟夫的人，他和他的 40 个士兵被罗马军队包围在一个洞中。他们决定宁愿自杀也不被敌人俘获，于是约瑟夫提议一个自杀方法：他们围成一个圈，从一个人开始，数到第三个人时将第三个人杀死，然后再数，直到所有人都死去。约瑟夫和另一个人不想自杀，所以他需要找到一个安全的位置。问题是：给定数到的数字 m 和总人数 n，哪些位置是安全的？

这个问题可以用递归来解决。设 f(n, m) 表示 n 个人数到 m 的最后一个存活的人的位置。当 n = 1 时，f(1, m) = 0。对于 n > 1 的情况，考虑第一个被杀的人的位置 k = (m - 1) % n，那么剩下的 n-1 个人组成的新编号是从 k+1 到 n-1，0 到 k-1。这个新编号的解是 f(n-1, m)，所以原来的解就是 (f(n-1, m) + k + 1) % n。

递归公式如下：
$$
f(1, m) = 0 
\\
 f(n, m) = (f(n-1, m) + m - 1) \% n + 1
$$
通过这个公式，我们可以计算出在 n 个人中数到 m 的情况下，安全的位置。

1. **递归方法**:

```java
public class Josephus {
    public static int josephusRecursive(int n, int m) {
        if (n == 1) {
            return 0;
        }
        return (josephusRecursive(n - 1, m) + m) % n;
    }

    public static void main(String[] args) {
        int n = 41; // 例如 41 个人
        int m = 3;  // 每数到第 3 个人
        System.out.println("The safe position is: " + (josephusRecursive(n, m) + 1)); // +1 是因为我们从 0 开始计数
    }
}
```

2. **非递归方法**:

```java
public class Josephus {
    public static int josephusIterative(int n, int m) {
        int result = 0;
        for (int i = 2; i <= n; i++) {
            result = (result + m) % i;
        }
        return result;
    }

    public static void main(String[] args) {
        int n = 41; // 例如 41 个人
        int m = 3;  // 每数到第 3 个人
        System.out.println("The safe position is: " + (josephusIterative(n, m) + 1)); // +1 是因为我们从 0 开始计数
    }
}
```

在这两个示例中，我们考虑了 41 个人和数到第 3 个人的情况。输出结果表示安全的位置。

## 2.项目中的某个业务点怎么实现的

## 3.Sentinel限流的原理，怎么实现的

Sentinel 是阿里巴巴开源的一个流量控制、熔断降级的 Java 库，提供了丰富的微服务治理功能，包括流量控制、熔断降级、系统负载保护等。

以下是 Sentinel 的主要限流原理和实现：

1. **统计数据结构**：Sentinel 使用滑动窗口的方式来统计数据。滑动窗口分为多个小的时间窗口，每个窗口记录在这段时间内的请求次数或响应时间等数据。

2. **限流算法**：Sentinel 主要提供了以下几种限流策略：

   - **直接拒绝**：当 QPS 超过某个预定值时，直接拒绝请求。
   - **Warm Up**：当系统启动时，限流器的阈值是从一个比较小的值开始，然后逐渐增加到预设的值，这样可以避免系统启动时被大量请求冲垮。
   - **匀速排队**：请求会被均匀地放行，而不是突发地放行，这样可以确保系统的稳定性。

3. **资源调用关系**：Sentinel 可以记录资源的调用关系，这样可以更好地进行流量控制和熔断降级。

4. **规则持久化**：Sentinel 支持将规则持久化到文件或其他外部存储中，这样可以实现动态修改规则而不需要重启应用。

5. **熔断降级**：除了流量控制，Sentinel 还提供了熔断降级的功能。当某个资源的响应时间超过预设的阈值或异常比例超过预设的阈值时，Sentinel 会自动进行熔断，拒绝对这个资源的访问，直到资源恢复正常。

6. **系统负载保护**：Sentinel 可以根据系统的负载，如 CPU 使用率、平均 RT、入口 QPS 等，动态地调整流量控制的阈值，确保系统不会被过多的请求冲垮。

实现细节：

- Sentinel 内部使用了一个名为 `StatisticSlot` 的统计槽来统计请求数据。
- `RuleManager` 负责管理流量控制和熔断降级的规则。
- `CircuitBreaker` 是熔断器的实现，当资源的指标超过阈值时，`CircuitBreaker` 会打开，拒绝对资源的访问。
- Sentinel 使用了责任链模式来处理请求，每个处理器都会对请求进行一些处理，如统计数据、检查规则等。

总的来说，Sentinel 的实现原理是通过统计请求数据，然后根据预设的规则来进行流量控制或熔断降级。其内部使用了多种设计模式和数据结构来确保高效和准确地进行流量控制。

## 4.数据在redis中存的时候用的什么数据结构

Redis 是一个高性能的键值存储系统，它支持多种数据结构。当我们谈论 "数据在 Redis 中存储时使用的数据结构" 时，可以从两个角度来看：一是 Redis 如何内部实现这些数据结构，二是 Redis 提供给用户的数据结构类型。

1. **Redis 提供给用户的数据结构类型**：

   - **字符串（String）**：可以存储字符串、整数或浮点数。
   - **列表（List）**：一个列表的集合，可以在头部或尾部插入元素。
   - **集合（Set）**：一个无序且不重复的字符串集合。
   - **有序集合（Sorted Set）**：字符串集合，每个字符串都会关联一个浮点数作为分数，根据分数进行排序。
   - **哈希（Hash）**：键值对的集合。
   - **位图（Bitmaps）**：通过字符串值实现的，可以看作是一个位数组。
   - **HyperLogLogs**：用于基数估计的数据结构。
   - **地理空间索引（Geospatial Indexes）**：可以存储地理位置信息，并进行相关查询。

2. **Redis 内部实现这些数据结构的方式**：

   - **简单动态字符串（SDS，Simple Dynamic String）**：Redis 的默认字符串表示，用于实现字符串类型。
   - **双向链表**：用于实现列表类型。
   - **字典（Dictionary）**：使用哈希表实现，用于实现哈希和 Redis 的内部数据结构，如数据库。
   - **跳跃列表（Skip List）**：用于实现有序集合。
   - **紧凑列表（ziplist）**：一个特殊的编码方式，用于存储小的有序集合或哈希。
   - **整数集合（intset）**：用于存储只包含整数的小集合。
   - **快速列表（quicklist）**：用于实现列表，是一个双向链表和紧凑列表的混合结构。
   - **基数树（Radix Tree）**：在 Redis 4.0 中引入，用于优化某些数据结构的内存使用。

这些内部数据结构使 Redis 能够高效地实现和存储用户数据，并在需要时进行优化，以减少内存使用或提高性能。

## 5.redis hash结构的缺点

Redis 的哈希结构是非常高效和实用的，但它也有一些缺点和限制：

1. **内存使用**：尽管哈希结构在存储大量小键值对时比单独使用字符串更节省内存，但对于非常大的哈希或包含大值的哈希，内存使用可能会变得昂贵。

2. **不适合大型数据**：如果哈希中存储了大量的字段，那么对其进行操作（例如删除或更新多个字段）可能会比较慢。

3. **不支持复杂查询**：与传统的关系型数据库或某些NoSQL数据库相比，Redis 哈希不支持复杂的查询。你不能对多个字段进行查询或执行连接操作。

4. **不支持内部过期**：虽然 Redis 键可以设置过期时间，但哈希内部的字段不能单独设置过期时间。如果你需要字段级别的过期，你必须自己实现。

5. **数据持久性**：与 Redis 的其他数据结构一样，如果你没有配置持久性或备份，那么在 Redis 重启或崩溃时，你可能会丢失数据。

6. **分布式环境的复杂性**：在分布式环境中，如使用 Redis Cluster，对哈希的操作可能会受到跨节点操作的影响，这可能会增加操作的复杂性。

7. **紧凑列表限制**：在某些情况下，为了节省内存，Redis 会使用紧凑列表（ziplist）来存储哈希。但是，当哈希增长并超过一定的大小或值的长度时，它会被转换为一个更传统的哈希表结构，这可能会导致突然的内存使用增加。

尽管存在上述缺点，但 Redis 哈希结构在许多场景中仍然是非常有用和高效的。在使用时，只需确保它适合你的特定需求，并考虑到其限制。

## 6.==和equals

## 7.重载和重写

## 8.线程有哪些状态，怎么切换的

Java 中的线程有以下几种状态，这些状态定义在 `Thread.State` 枚举中：

1. **NEW (新建)**: 线程刚被创建，但还没有调用 `start()` 方法。

2. **RUNNABLE (可运行)**: 线程正在 Java 虚拟机中执行，但它可能正在等待操作系统中的其他资源（例如处理器）。

3. **BLOCKED (阻塞)**: 线程正在等待一个监视器锁，这通常是因为它正在尝试进入一个 `synchronized` 块/方法，而该块/方法已经被其他线程锁定。

4. **WAITING (等待)**: 线程正在无限期地等待另一个线程执行特定的操作。例如，它可能正在调用以下方法之一：
   - `Object.wait()`
   - `Thread.join()`
   - `LockSupport.park()`

5. **TIMED_WAITING (计时等待)**: 线程正在等待另一个线程执行操作，但最多等待指定的时间。它可能在调用以下方法之一，并指定了等待时间：
   - `Thread.sleep(long millis)`
   - `Object.wait(long timeout)`
   - `Thread.join(long millis)`
   - `LockSupport.parkNanos()`
   - `LockSupport.parkUntil()`

6. **TERMINATED (终止)**: 线程已经执行完毕。

**状态切换**:

- **从 NEW 到 RUNNABLE**: 调用 `Thread.start()` 方法。
- **从 RUNNABLE 到 BLOCKED**: 当线程尝试获取一个对象的锁，而该锁当前被其他线程持有。
- **从 RUNNABLE 到 WAITING/TIMED_WAITING**: 当线程调用了如 `Object.wait()`, `Thread.join()`, 或 `Thread.sleep()` 这样的方法。
- **从 BLOCKED 到 RUNNABLE**: 当线程获取到了之前被阻塞的锁。
- **从 WAITING/TIMED_WAITING 到 RUNNABLE**: 当等待的条件得到满足，如 `Object.notify()`, `Object.notifyAll()`, `Thread.sleep()` 时间到达，或是 `Thread.join()` 中指定的线程终止。
- **从 RUNNABLE 到 TERMINATED**: 当线程的 `run()` 方法执行完毕或线程中断。

线程的状态切换是由 JVM、操作系统和线程的方法调用共同决定的。理解这些状态及其转换对于正确和高效地使用多线程非常重要。

## 9.java集合有哪些东西

## 10.sleep和wait

## 11.怎么创建一个线程

## 12.线程池默认的线程数是多少

1. `Executors.newFixedThreadPool(int nThreads)`：创建一个固定大小的线程池，其中`nThreads`是你指定的线程数。
2. `Executors.newCachedThreadPool()`：创建一个可以根据需要创建新线程的线程池，但在先前构建的线程可用时将重用它们。核心线程数为0，最大线程数为`Integer.MAX_VALUE`。
3. `Executors.newSingleThreadExecutor()`：创建一个只有一个线程的线程池。

## 13.线程池的详细理解，比如说什么时候加入等待队列之类的，好几个连续的

## 14.主线程等待多个子线程执行完才继续执行怎么实现

## 15.父线程子线程、父进程主进程之间的各种东西，死亡回收之类的？

当我们谈论父子进程及其死亡回收时，我们通常是在讨论UNIX或类UNIX系统（如Linux）上的进程管理。

在这些系统中，当一个进程（父进程）创建一个新进程（子进程）时，子进程可以独立于父进程运行。当子进程结束运行并退出时，它不会立即从系统中消失。它会变成一个"僵尸进程"（zombie process），等待其父进程读取其退出状态。这是为了让父进程知道子进程的退出状态以及为什么它已经结束。

父进程通过调用`wait()`或`waitpid()`系统调用来读取子进程的退出状态。一旦父进程读取了子进程的退出状态，子进程就会被完全从系统中删除。

但是，如果父进程没有调用`wait()`或`waitpid()`，子进程就会保持其僵尸状态。这通常不是一个大问题，因为僵尸进程不使用任何系统资源（除了进程表中的一个条目）。但是，如果有大量的僵尸进程累积，它们可能会消耗所有可用的进程ID，从而导致系统无法启动新的进程。

为了防止僵尸进程的累积，父进程应该总是尝试回收其子进程。如果父进程在子进程之前结束，子进程会被init进程（PID为1的进程）所采纳，init进程会定期调用`wait()`来回收任何僵尸进程，从而确保它们不会永远留在系统中。

总之，父子进程之间的死亡回收是UNIX和类UNIX系统中进程管理的一个重要方面，它确保资源得到适当的清理和回收。

## 16.怎么打断正在执行的线程（跟线程没完没了了）

## 17.mysql聚集索引，200w数据变成2000w数据，查询速度会不会变慢

## 18.索引失效的场景

1、在索引列上面发生计算

2、在索引列上面发生隐式转换

3、在索引列上面使用函数，如日期函数等

4、使用模糊查询的时候前面使用%

5、没有遵循最左前缀原则

6、使用or链接的查询可能会失效

7、not null、is not null、<>等会引起索引失效

## 19.select *为什么会索引失效

不会导致索引失效，只是查询速度慢的问题

## 20.redis SDS的特点

Redis的字符串表示使用了一个叫做SDS（Simple Dynamic String，简单动态字符串）的结构。SDS提供了一种灵活且高效的方式来表示字符串，它具有以下特点：

1. **O(1)时间复杂度的长度查询**：SDS结构存储了字符串的长度，因此获取字符串长度的操作是O(1)时间复杂度，而不是传统C字符串的O(n)。

2. **减少缓冲区溢出的风险**：SDS确保了在进行字符串操作时，总是会检查并适当地分配内存，这与传统的C字符串操作不同，后者可能会导致缓冲区溢出。

3. **二进制安全**：SDS可以存储任何包含'\0'字符的二进制数据，这与传统的C字符串不同，后者使用'\0'来标识字符串的结束。

4. **预分配策略**：当SDS字符串需要增长时，除了为它们分配所需的内存外，SDS还会预分配额外的未使用的空间。这种策略是为了减少连续的内存重新分配操作，从而提高字符串追加操作的性能。

5. **惰性空间释放**：当SDS字符串缩短时，它不会立即释放未使用的内存，而是使用一个free属性来记录这些未使用的空间，这样可以在后续的追加操作中重用这些空间，从而避免频繁的内存重新分配。

6. **与C字符串兼容**：尽管SDS提供了许多优点，但它在内部仍然以null-terminated的方式存储，这意味着SDS可以与那些期望传统C字符串的函数一起使用。

7. **动态大小**：SDS可以根据需要动态地调整其大小，这使得它非常适合于Redis这样的用途，因为Redis需要处理各种大小的字符串数据。

这些特点使得SDS在Redis中成为一个非常合适的字符串表示方式，它提供了性能优势并减少了与传统C字符串操作相关的常见问题。

## 21.redis集群中某个节点的流量偏大，可能是什么原因

### Redis 集群节点流量偏大的可能原因

当 Redis 集群中的某个节点流量偏大时，可能是由以下几个原因导致的：

1. **数据分布不均**：Redis 集群的数据分布是基于哈希槽的，如果某些高频访问的 key 被分配到了同一个节点，那么这个节点的流量就会偏大。

2. **热点 Key**：某些特定的 key 可能被大量客户端频繁访问，导致流量集中。

3. **复制延迟**：如果一个主节点的写入量很大，其对应的从节点可能会出现复制延迟，导致流量增大。

4. **网络问题**：可能是由于网络配置或硬件问题，导致某些节点之间的通信变慢，从而影响流量。

5. **节点配置不一致**：如果集群中的节点配置不一致，例如某些节点的内存、CPU 或磁盘性能较差，可能会导致这些节点处理请求的速度较慢，从而影响流量。

6. **命令使用不当**：例如，使用 `KEYS *` 这样的命令可能会导致大量的流量。

7. **持久化方式**：如果某个节点配置了 AOF 持久化，并且 AOF 重写发生得很频繁，那么这个节点的流量可能会偏大。

8. **客户端连接数**：某个节点的客户端连接数过多也可能导致流量偏大。

为了解决这个问题，您可以考虑重新分配哈希槽，使数据更均匀地分布在各个节点上，或者优化客户端的访问模式，避免热点 Key 的出现。

```markdown
**答案**:
- 数据分布不均
- 热点 Key
- 复制延迟
- 网络问题
- 节点配置不一致
- 命令使用不当
- 持久化方式
- 客户端连接数
```

希望这可以帮助您诊断和解决问题。

## 22.红黑树和链表的区别

## 23.代理模式怎么使用的

## 24.反问

## 25.不知道为什么反问之后又问了我职业规划、毕设、有没有offer，没说二面的事