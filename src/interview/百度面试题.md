---
# 当前页面内容标题
title: 百度一面
# 当前页面图标
icon: write
# 分类
category:
  - 面试真题
# 标签
tag:
  - Java
---



自我介绍

项目的难点，怎么解决的

> TODO 首先构造一个环境吧，然后解释说为什么这样做，千万不要给自己挖坑，要埋点，建议提前准备一下

实习公司的项目，做了些什么

对比有目的性的去学习和普通学习有什么区别

> 这里主要说到我项目难点的问题，衍生出来的问题

hashmap的底层数据结构

> 在JDK1.7之前，底层是链表加上数组，并且链表的插入方式是头插法，但是在JDK1.8以后，底层就是数组加上链表加上红黑树，链表的插入方式变成了后端插入，为什么呢？因为1.7采用头插的时候，多线程环境下，头部插入容易造成并发死链问题和数据丢失问题，就是在扩容的时候会出现错误，造成线程死循环，在1.8以后，就改为尾部插入，只会造成数据丢失

什么时候转换为红黑树

> 默认的是8转换为红黑树，至于为什么是8，根据泊松分布算出来的，~~当红黑树大小小于6，会转换回来~~ 
>
> 当红黑树的根节点、左右儿子节点、左孙子不为空，就不会转换回链表，不是规定的6

一百万数据存到hashmap中，怎么优化

线程池的参数有哪些

> 全部参数有七个：
>
> 第一个：核心线程数
>
> 第二个：最大线程数
>
> 第三个：时间大小
>
> 第四个：时间单位
>
> 第五个：线程工程
>
> 第六个：阻塞队列
>
> 第七个：拒绝策略
>
> 设置规则：
>
> 1. cpu密集型任务:最大线程数 = cpu核数 + 1
> 2. io密集型任务:最大线程数 = cpu核数 * 2
> 3. workQueue大小为cpu核数的2-3倍
> 4. keepAliveTime设置为60-120秒
> 5. 设置饱和策略,一般设置为CallerRunsPolicy

线程池的阻塞队列如何选择

> 有界队列和无界队列，
>
> 如果任务可以等待则建议使用无界队列(Integer.MAX_VALUE),任务实时性强则建议使用有界队列。
>
> 队列的阻塞策略：常见的有直接提交、抛出异常和阻塞等待三种。直接提交不管队列是否已满,抛出异常则在队列满时抛异常。阻塞等待在队列满的时候会阻塞生产者线程。
>
> 队列的容量。容量大小直接影响到线程池中最大排队的任务数量。容量过小会频繁地 rejecting任务;容量过大则会占用过多内存。
>
> 队列的类型。常见的有三种:ArrayBlockingQueue(数组)、LinkedBlockingQueue(链表)、SynchronousQueue(直接提交)。数组和链表区别在于链表可以灵活地变化容量,数组则需预先设定。SynchronousQueue 不存储任务,直接提交给线程执行。

线程池的默认拒绝策略是什么？

> 丢弃和抛异常

你项目中使用的线程池的拒绝策略是什么？为什么？

> 项目中使用的CallerRunsPolicy（调用者运行策略）： 这是一种简单的拒绝策略，当线程池无法接受新任务时，由提交该任务的线程来执行该任务。这样可以避免丢失任务，但可能会导致提交任务的线程也变得繁忙，影响整体性能。

Runnable和Callable有什么区别?

> 这两个都是一个接口，都可以创建出一个线程来，但是Runnable和Callable还是有区别的
>
> 首先是需要重写的方法不同
>
> ​		Runnable重写的方法是：run方法
>
> ​		Callable重写的方法是：call方法
>
> 需要配合的类不一样
>
> ​		Runnable可以配合Thread进行创建线程
>
> ​		Callable可以配合FutureTask来进行使用，并且需要注意的是
>
> ​				 FutureTask启动的方法不是start，而是run方法，并且因为Callable是由返回值的，线程里面出现的异常和结构都需要吊起FutureTask的get方法获取，否则就不能捕获异常，就不知道发送了什么，而且get方法还是阻塞的

什么场景使用Runnable，什么场景使用Callable？

> 在给线程创建的方法需要返回值的时候，就使用Callable，不关心结果，只关心执行过程的就可以使用Runnable

使用的时候如果发生异常怎么捕获？

> 可以使用try-catch进行捕获，可以加在线程的里面

JVM的内存区域

> 程序计数器
>
> 方法区
>
> 堆
>
> 直接内存
>
> 运行时常量池
>
> 虚拟机栈
>
> 本地方法栈

JVM的参数，怎么设置，你项目中如何调优？

> 1. 常用JVM参数：
>    - -Xms<size>: 设置JVM的初始堆大小。
>    - -Xmx<size>: 设置JVM的最大堆大小。
>    - -Xss<size>: 设置每个线程的栈大小。
>    - -XX:NewRatio=<value>: 设置年轻代和老年代的大小比例。
>    - -XX:SurvivorRatio=<value>: 设置Eden区与Survivor区的大小比例。
>    - -XX:MaxPermSize=<size>: 设置永久代（在JDK 8之前）或元空间（在JDK 8及以后）的最大大小。
>    - -XX:MaxDirectMemorySize=<size>: 设置直接内存的最大大小。
>    - -XX:+UseParallelGC: 使用并行垃圾收集器。
>    - -XX:+UseConcMarkSweepGC: 使用并发标记-清除垃圾收集器。
>    - -XX:+UseG1GC: 使用G1垃圾收集器。
>    - -XX:+DisableExplicitGC: 禁止手动调用System.gc()方法。
> 2. 调优技巧：
>    - 合理设置堆大小：根据应用程序的内存需求和服务器硬件情况，调整-Xms和-Xmx参数，避免频繁的垃圾回收和内存溢出。
>    - 选择合适的垃圾收集器：不同的垃圾收集器适用于不同的场景，根据应用程序的特点选择合适的垃圾收集器。
>    - 使用并发垃圾收集器：对于多核处理器，使用并发垃圾收集器可以减少垃圾收集时的停顿时间，提高应用程序的响应性。
>    - 减少全局同步：避免过多的全局同步操作，使用局部变量和线程安全的数据结构来减少线程间的竞争。
>    - 优化代码：尽可能使用高效的算法和数据结构，避免无谓的对象创建和销毁，减少内存使用和垃圾产生。

算法题：简单二分