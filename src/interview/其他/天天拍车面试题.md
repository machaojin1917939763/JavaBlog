---
title: 天天拍车面试题
order: 2
category:
  - 天天拍车
tag:
  - 天天拍车
---



## 自我介绍

## 介绍一下最有意思的项目

## 项目的难点是什么，怎么解决的

## 针对项目提问

## rabbitmq的四大交换机


RabbitMQ是一个流行的消息代理，它支持多种消息模型。在RabbitMQ中，交换机（Exchanges）是用来接收生产者发送的消息并将它们路由到消息队列的组件。RabbitMQ提供了四种主要类型的交换机：

1. **Direct Exchange**:
   - **名称**: `direct`
   - **工作方式**: 它将消息路由到那些binding key与routing key完全匹配的队列中。
   - **用途**: 当你想根据特定的规则路由消息时，直接交换机是很有用的。
2. **Fanout Exchange**:
   - **名称**: `fanout`
   - **工作方式**: 它将接收到的消息广播到所有绑定的队列，而不考虑绑定的键。
   - **用途**: 当你希望广播消息到多个消费者时，fanout交换机是很有用的。
3. **Topic Exchange**:
   - **名称**: `topic`
   - **工作方式**: 它将消息路由到那些binding key与routing key匹配的队列中。这里的匹配支持通配符，如`*`（匹配一个词）和`#`（匹配零个或多个词）。
   - **用途**: 当你想根据特定的模式路由消息时，主题交换机是很有用的。
4. **Headers Exchange**:
   - **名称**: `headers`
   - **工作方式**: 它不依赖于routing key的规则，而是根据发送的消息内容中的headers属性进行匹配。如果一个队列的绑定头与消息的头匹配（或者满足x-match的条件），那么消息将被路由到该队列。
   - **用途**: 当你想根据消息头的属性而不是routing key来路由消息时，headers交换机是很有用的。

## rabbitmq有什么作用

rabbitmq主要有以下作用:

1. 提供可靠的消息队列服务。rabbitmq可以为分布式系统提供可靠的异步消息队列,用于不同系统之间或系统内不同组件之间的解耦和通信。
2. 实现应用程序的异步处理和削峰填谷。通过rabbitmq的消息队列,可以让生产者和消费者异步地处理任务,不需要同步地处理,从而提高系统并发能力。并且可以缓冲和削峰填谷。
3. 实现多种消息模式。rabbitmq支持多种消息模式,如点对点、发布订阅、工作队列等,可以实现不同的业务需求。
4. 提供可靠消息传输。rabbitmq通过消息确认机制和持久化可以保证消息不丢失,支持事务来确保消息的一致性。
5. 扩展性好。rabbitmq是基于Erlang构建,可以在集群中部署,setUp主从模式,能够支持高可用和海量消息。
6. 多语言客户端支持。rabbitmq几乎支持所有常用语言,使用方便。
7. 管理界面友好。rabbitmq提供了易用的管理界面,可以监控和管理消息、队列、交换器等,非常方便

## MySQL的锁的类型是由什么决定的

MySQL 的锁类型是由多个因素决定的，主要包括存储引擎、操作类型和隔离级别。以下是一些常见的 MySQL 锁类型及其决定因素：

1. **存储引擎**：不同的存储引擎支持不同的锁类型。
   - **MyISAM**：支持表级锁（table-level locking）。这意味着当一个线程对表进行写操作时，其他线程不能对该表进行读或写操作。
   - **InnoDB**：支持行级锁（row-level locking）和表级锁。行级锁允许多个事务同时对不同的行进行操作，从而提高了并发性。
2. **操作类型**：不同的 SQL 操作可能会触发不同的锁类型。
   - 例如，`SELECT ... FOR UPDATE` 在 InnoDB 中会触发行级的排他锁（exclusive lock）。
   - `LOCK TABLES ... WRITE` 会触发表级的排他锁。
3. **隔离级别**：在 InnoDB 存储引擎中，事务的隔离级别会影响锁的行为。以下是四个隔离级别：
   - **READ UNCOMMITTED**：最低的隔离级别，允许读取未提交的数据。
   - **READ COMMITTED**：只能读取已提交的数据。这是 MySQL 的默认隔离级别。
   - **REPEATABLE READ**：在事务开始时创建一个快照，确保在整个事务期间看到的数据都是一致的。
   - **SERIALIZABLE**：最高的隔离级别，会在所有读取的行上放置共享锁。
4. **意向锁**：InnoDB 使用意向锁（intention locks）来表明它接下来打算放置哪种类型的锁（共享锁或排他锁）。这是一种优化手段，用于减少锁冲突的可能性。
5. **记录锁**：锁定单个或多个行。
6. **间隙锁**：锁定一个范围，但不包括实际的行。
7. **自适应哈希索引锁**：当数据在内存中被频繁访问时，InnoDB 可能会创建一个自适应哈希索引，并可能对其进行锁定。
8. **元数据锁**：当对表结构进行更改时（例如，使用 ALTER TABLE），MySQL 会使用元数据锁。

了解 MySQL 的锁类型及其决定因素对于优化数据库性能和解决锁冲突非常重要。

## MySQL有哪些锁

MySQL 中的锁机制是为了保证数据的并发性和一致性。以下是 MySQL 中常见的锁类型：

### 1. 全局锁
MySQL 可以对整个数据库实例加锁，这种锁称为全局锁。通常情况下，我们不会直接使用它，但在进行某些全库操作时，如备份，可能会用到。

```markdown
- **命令**：`FLUSH TABLES WITH READ LOCK;`
```

### 2. 表锁
表锁是 MySQL 中最简单的锁策略，它会锁定整个表。这种锁的开销小，锁定快，不会出现死锁，锁定的粒度大，发生锁冲突的概率最高，对数据库的并发性能影响也最大。

```markdown
- **命令**：`LOCK TABLES ... READ/WRITE;`
```

### 3. 行锁
行锁是最细粒度的锁，它锁定数据表中的一行。行锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。

```markdown
- **使用**：InnoDB 存储引擎实现了行锁。
```

### 4. 间隙锁
间隙锁是 InnoDB 为了防止幻读而引入的一种锁机制。它并不是锁定某一行，而是锁定某一行与前一行之间的“间隙”。

```markdown
- **特点**：防止其他事务在该区间插入新的记录。
```

### 5. 意向锁
意向锁是一种表明事务将要在表的某个行上设置共享锁或排他锁的锁。这是为了在表锁和行锁之间建立一种协议，使得多个事务可以在同一时间对表的不同部分加锁。

```markdown
- **类型**：意向共享锁、意向排他锁。
```

### 6. 记录锁
记录锁是锁定某些特定的行。

```markdown
- **使用**：通过索引来锁定。
```

### 7. 临键锁 (Next-Key Lock)
临键锁是记录锁和间隙锁的结合，它锁定一个索引记录和它之前的间隙。

```markdown
- **特点**：确保行的范围不被其他事务修改。
```

这些锁类型在不同的场景和存储引擎中有不同的应用和表现。理解它们的工作原理和使用场景对于优化 MySQL 性能和解决并发问题非常重要。

## MySQL的事务和spring的事务传播级别有什么区别

MySQL 的事务和 Spring 的事务传播级别是两个不同的概念，但它们都与事务处理有关。以下是它们之间的主要区别：

### MySQL 事务

MySQL 事务主要关注数据库层面的事务处理。它的核心特点是 ACID：

1. **原子性 (Atomicity)**：事务中的所有操作，要么全部完成，要么全部不完成。
2. **一致性 (Consistency)**：事务必须使数据库从一个一致性状态转移到另一个一致性状态。
3. **隔离性 (Isolation)**：并发执行的事务之间互不干扰。
4. **持久性 (Durability)**：一旦事务提交，其结果就是永久性的。

MySQL 提供了 COMMIT、ROLLBACK 和 SAVEPOINT 等命令来控制事务。

### Spring 事务传播级别

Spring 的事务传播级别是 Spring 框架提供的，它定义了事务的传播行为。当一个事务方法被另一个事务方法调用时，这些传播行为决定了事务如何执行。Spring 提供了以下传播级别：

1. **REQUIRED**：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。
2. **SUPPORTS**：使用当前的事务，如果当前没有事务，就按非事务方式执行。
3. **MANDATORY**：使用当前的事务，如果当前没有事务，就抛出异常。
4. **REQUIRES_NEW**：新建事务，如果当前存在事务，把当前事务挂起。
5. **NOT_SUPPORTED**：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
6. **NEVER**：以非事务方式执行，如果当前存在事务，则抛出异常。
7. **NESTED**：如果当前存在事务，则嵌套事务执行，嵌套事务是独立的事务，对于外部事务是透明的。如果当前没有事务，就新建一个事务。

```markdown
- **注意**：Spring 的事务传播级别是在应用层面控制事务的行为，而不是在数据库层面。
```

总结，MySQL 的事务关注的是如何在数据库层面保证数据的完整性和一致性，而 Spring 的事务传播级别关注的是在应用层面如何控制事务的行为，特别是在多个事务方法相互调用的情况下。

## redis有哪些命令执行时间可能会比较长

Redis 是一个高性能的键值存储系统，但某些命令在特定的情况下可能会导致较长的执行时间，从而影响 Redis 的响应时间。以下是一些可能导致较长执行时间的 Redis 命令：

### 1. `KEYS`
- **描述**：该命令会返回所有匹配给定模式的键。
- **问题**：当 Redis 数据库中有大量的键时，这个命令可能会导致 Redis 阻塞。

```markdown
- **建议**：在生产环境中避免使用 `KEYS` 命令，可以使用 `SCAN` 命令替代。
```

### 2. `SMEMBERS`
- **描述**：返回集合中的所有成员。
- **问题**：对于大的集合，这可能会消耗大量的时间和内存。

```markdown
- **建议**：如果只是检查成员的存在性，使用 `SISMEMBER`。如果需要迭代集合，可以考虑使用 `SSCAN`。
```

### 3. `HGETALL`
- **描述**：获取哈希表中的所有字段和值。
- **问题**：对于大的哈希表，这可能会消耗大量的时间和内存。

```markdown
- **建议**：如果不需要所有字段和值，可以使用 `HGET` 或 `HMGET`。如果需要迭代哈希表，可以考虑使用 `HSCAN`。
```

### 4. `LRANGE`
- **描述**：返回列表中指定范围内的元素。
- **问题**：请求大范围的元素可能会很慢。

```markdown
- **建议**：尽量请求较小的范围。
```

### 5. `SUNION`, `SDIFF`, `SINTER`
- **描述**：这些命令分别返回多个集合的并集、差集和交集。
- **问题**：当操作的集合很大时，这些命令可能会很慢。

```markdown
- **建议**：考虑数据结构的设计，以减少大集合的操作。
```

### 6. `SORT`
- **描述**：对列表、集合或有序集合进行排序。
- **问题**：对大量数据进行排序可能会很慢。

```markdown
- **建议**：如果可能，尽量在应用层进行排序，或者考虑使用其他数据结构如有序集合（ZSET）。
```

### 7. `FLUSHDB` 和 `FLUSHALL`
- **描述**：这些命令分别删除当前数据库的所有键和所有数据库的所有键。
- **问题**：这些命令会导致 Redis 阻塞，直到所有的键都被删除。

```markdown
- **建议**：在生产环境中谨慎使用这些命令。
```

### 8. `SAVE`
- **描述**：执行同步保存操作。
- **问题**：这会阻塞 Redis 直到保存操作完成。

```markdown
- **建议**：使用 `BGSAVE` 命令进行后台保存。
```

这些命令在某些情况下可能会导致较长的执行时间，但这也取决于数据的大小和硬件性能。在生产环境中，应该避免使用可能导致阻塞的命令，并定期监控 Redis 的性能。 

## 线程池有什么作用，目的是什么

线程池是多线程编程中常用的一个概念，主要用于管理和控制线程的生命周期和执行。线程池的主要作用和目的如下：

### 1. 资源重用

- **描述**：创建和销毁线程需要时间和系统资源。线程池通过重用已创建的线程，避免了频繁地创建和销毁线程。
  
```markdown
- **优势**：提高了资源的使用效率。
```

### 2. 控制并发线程数

- **描述**：线程池允许开发者设置并发线程的最大数量，从而避免了大量线程同时运行导致的系统过载。
  
```markdown
- **优势**：保证了系统的稳定性和响应性。
```

### 3. 管理线程生命周期

- **描述**：线程池管理线程的整个生命周期，包括创建、执行、中断和销毁。
  
```markdown
- **优势**：简化了多线程编程的复杂性。
```

### 4. 提高响应速度

- **描述**：当系统需要执行一个任务时，如果线程池中有空闲线程，可以立即执行，无需等待线程创建。
  
```markdown
- **优势**：提高了系统的响应速度。
```

### 5. 提供任务调度

- **描述**：线程池通常配合工作队列使用，允许任务按照某种策略（如先进先出、优先级等）进行调度和执行。
  
```markdown
- **优势**：提供了更灵活的任务执行策略。
```

### 6. 资源限制和管理

- **描述**：线程池限制了系统中线程的最大数量，避免了因为创建过多线程导致的资源耗尽或系统崩溃。
  
```markdown
- **优势**：提高了系统的稳定性。
```

### 7. 减少系统开销

- **描述**：频繁地创建和销毁线程会导致大量的系统开销。线程池通过线程重用减少了这种开销。
  
```markdown
- **优势**：提高了系统的整体性能。
```

总的来说，线程池的主要目的是提高系统性能、稳定性和响应性，同时简化多线程编程的复杂性。在处理大量并发任务时，使用线程池通常比直接创建线程更加高效和稳定。

## 场景题：如何实现对一个url计数

## 反问环节

## 你是如何学习的



